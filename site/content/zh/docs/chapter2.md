---
weight: 2
title: '2. 套接字和模式'
---

# 第2章 - 套接字和模式 {#sockets-and-patterns}

在第一章中，我们体验了 ZeroMQ，通过一些主要 ZeroMQ 模式的基本示例：请求-回复、发布-订阅和管道。在本章中，我们将深入了解并开始学习如何在真实程序中使用这些工具。

我们将涵盖：

* 如何创建和使用 ZeroMQ 套接字。
* 如何在套接字上发送和接收消息。
* 如何围绕 ZeroMQ 的异步 I/O 模型构建应用程序。
* 如何在一个线程中处理多个套接字。
* 如何正确处理致命和非致命错误。
* 如何处理中断信号，如 Ctrl-C。
* 如何干净地关闭 ZeroMQ 应用程序。
* 如何检查 ZeroMQ 应用程序的内存泄漏。
* 如何发送和接收多部分消息。
* 如何跨网络转发消息。
* 如何构建简单的消息队列代理。
* 如何使用 ZeroMQ 编写多线程应用程序。
* 如何使用 ZeroMQ 在线程之间发送信号。
* 如何使用 ZeroMQ 协调节点网络。
* 如何为发布-订阅创建和使用消息信封。
* 使用 HWM（高水位标记）防止内存溢出。

## 套接字 API {#The-Socket-API}

说实话，ZeroMQ 对你玩了一个偷梁换柱的把戏，我们对此不道歉。这是为了你好，这比伤害你更伤害我们。ZeroMQ 呈现了一个熟悉的基于套接字的 API，这需要我们付出巨大努力来隐藏一堆消息处理引擎。然而，结果将慢慢修复你关于如何设计和编写分布式软件的世界观。

套接字是网络编程的事实标准 API，也有助于防止你的眼睛掉到脸颊上。使 ZeroMQ 对开发人员特别有吸引力的一点是它使用套接字和消息，而不是其他任意的概念集合。向 Martin Sustrik 致敬，他做到了这一点。它将"面向消息的中间件"（一个保证会让整个房间都陷入昏迷状态的短语）变成了"超级辣味套接字！"，这让我们对披萨有了奇怪的渴望，并渴望了解更多。

就像一道最喜欢的菜一样，ZeroMQ 套接字很容易消化。套接字有四个部分的生命，就像 BSD 套接字一样：

* 创建和销毁套接字，它们一起形成套接字生命的因果循环（参见 `zmq_socket()`、`zmq_close()`）。

* 通过设置选项和必要时检查它们来配置套接字（参见 `zmq_setsockopt()`、`zmq_getsockopt()`）。

* 通过创建到套接字的 ZeroMQ 连接将套接字插入网络拓扑（参见 `zmq_bind()`、`zmq_connect()`）。

* 通过在套接字上写入和接收消息来使用套接字承载数据（参见 `zmq_msg_send()`、`zmq_msg_recv()`）。

请注意，套接字总是 void 指针，消息（我们很快就会讲到）是结构体。所以在 C 中你按原样传递套接字，但在所有处理消息的函数中传递消息的地址，如 `zmq_msg_send()` 和 `zmq_msg_recv()`。作为助记符，要意识到"在 ZeroMQ 中，所有你的套接字都属于我们"，但消息是你在代码中实际拥有的东西。

创建、销毁和配置套接字的工作方式与你对任何对象的期望一样。但请记住，ZeroMQ 是一个异步的、弹性的结构。这对我们如何将套接字插入网络拓扑以及之后如何使用套接字有一些影响。

### 将套接字插入拓扑 {#Plugging-Sockets-into-the-Topology}

要在两个节点之间创建连接，你在一个节点中使用 `zmq_bind()`，在另一个节点中使用 `zmq_connect()`。作为一般经验法则，执行 `zmq_bind()` 的节点是"服务器"，位于众所周知的网络地址上，而执行 `zmq_connect()` 的节点是"客户端"，具有未知或任意的网络地址。因此我们说我们"将套接字绑定到端点"和"将套接字连接到端点"，端点是那个众所周知的网络地址。

ZeroMQ 连接与经典的 TCP 连接有些不同。主要的显著差异是：

* 它们跨任意传输（`inproc`、`ipc`、`tcp`、`pgm` 或 `epgm`）。参见相关文档。

* 一个套接字可能有许多传出和传入连接。

* 没有 `zmq_accept()` 方法。当套接字绑定到端点时，它会自动开始接受连接。

* 网络连接本身在后台发生，如果网络连接中断（例如，如果对等体消失然后回来），ZeroMQ 将自动重新连接（PAIR 套接字除外）。

* 你的应用程序代码不能直接处理这些连接；它们被封装在套接字下。

许多架构遵循某种客户端/服务器模型，其中服务器是最静态的组件，客户端是最动态的组件，即它们来来去去最多。有时存在寻址问题：服务器对客户端可见，但不一定反之亦然。所以通常很明显哪个节点应该执行 `zmq_bind()`（服务器）和哪个应该执行 `zmq_connect()`（客户端）。这也取决于你使用的套接字类型，对于不寻常的网络架构有一些例外。我们稍后会看套接字类型。

现在，想象我们在启动服务器*之前*启动客户端。在传统网络中，我们得到一个大红色的失败标志。但 ZeroMQ 让我们任意启动和停止片段。一旦客户端节点执行 `zmq_connect()`，连接就存在，该节点可以开始向套接字写入消息。在某个阶段（希望在消息排队太多以至于开始被丢弃或客户端阻塞之前），服务器启动，执行 `zmq_bind()`，ZeroMQ 开始传递消息。

服务器节点可以绑定到许多端点（即协议和地址的组合），并且可以使用单个套接字来执行此操作。这意味着它将接受跨不同传输的连接：

```c
zmq_bind (socket, "tcp://*:5555");
zmq_bind (socket, "tcp://*:9999");
zmq_bind (socket, "inproc://somename");
```

对于大多数传输，你不能两次绑定到同一个端点，这与例如 UDP 不同。然而，`ipc` 传输确实允许一个进程绑定到已被第一个进程使用的端点。这旨在允许进程在崩溃后恢复。

虽然 ZeroMQ 试图对哪一边绑定和哪一边连接保持中立，但存在差异。我们稍后会更详细地看到这些。结果是你通常应该将"服务器"视为拓扑的静态部分，绑定到或多或少固定的端点，将"客户端"视为来来去去并连接到这些端点的动态部分。然后，围绕这个模型设计你的应用程序。这样"正常工作"的机会要好得多。

套接字有类型。套接字类型定义套接字的语义、其路由消息进出的策略、排队等。你可以将某些类型的套接字连接在一起，例如发布者套接字和订阅者套接字。套接字在"消息模式"中一起工作。我们稍后会更详细地看这个。

以这些不同方式连接套接字的能力给了 ZeroMQ 作为消息队列系统的基本力量。在此之上有层，例如代理，我们稍后会讲到。但本质上，使用 ZeroMQ，你通过像儿童建筑玩具一样将片段插在一起来定义你的网络架构。

### 发送和接收消息 {#Sending-and-Receiving-Messages}

要发送和接收消息，你使用 `zmq_msg_send()` 和 `zmq_msg_recv()` 方法。名称是常规的，但 ZeroMQ 的 I/O 模型与经典的 TCP 模型足够不同，你需要时间来理解它。

ZeroMQ 套接字承载消息，如邮政信件，而不是 TCP 套接字的字节流。ZeroMQ 消息是指定长度的二进制数据 blob。我们稍后会讲到消息。
