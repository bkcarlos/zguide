---
weight: 6
title: '6. ZeroMQ社区'
---

# 第6章 - ZeroMQ社区 {#the-community}

人们有时会问我ZeroMQ有什么特别之处。我的标准答案是，ZeroMQ可以说是我们对"如何制作21世纪所需的分布式软件"这个令人烦恼的问题的最佳答案。但除此之外，ZeroMQ之所以特别，是因为它的社区。这最终是区分狼群和羊群的因素。

开源有三种主要模式。第一种是大公司倾倒代码来破坏其他人的市场。这是Apache基金会模式。第二种是小团队或小公司构建他们的梦想。这是最常见的开源模式，在商业上可能非常成功。最后一种是积极而多样化的社区蜂拥解决问题景观。这是Linux模式，也是我们在ZeroMQ中所渴望的模式。

很难过分强调一个运作良好的开源社区的力量和持久性。长期来看，似乎真的没有更好的软件制作方式。社区不仅选择要解决的最佳问题，而且以最小化、仔细的方式解决它们，然后照顾这些解决方案多年甚至几十年，直到它们不再相关，然后悄悄地将它们收起来。

要真正从ZeroMQ中受益，你需要理解这个社区。在某个时候，你会想要提交一个补丁、一个问题或一个附加组件。你可能想要寻求帮助。你可能会想要将你业务的一部分押注在ZeroMQ上，当我告诉你社区比支持产品的公司重要得多时，即使我是那家公司的CEO，这应该是有意义的。

在这一章中，我将从几个角度审视我们的社区，并通过详细解释我们的协作合约作为结论，[我们称之为"C4"](http://rfc.zeromq.org/spec:22)。你应该发现这个讨论对你自己的工作很有用。我们还成功地将ZeroMQ C4流程适配到了闭源项目中。

我们将涵盖：

* ZeroMQ作为一系列项目的粗略结构
* "软件架构"真正的意义
* 为什么我们使用LGPL而不是BSD许可证
* 我们如何设计和发展ZeroMQ社区
* 支持ZeroMQ的业务
* 谁拥有ZeroMQ源代码
* 如何制作并提交ZeroMQ补丁
* 谁控制实际进入ZeroMQ的补丁
* 我们如何保证与旧代码的兼容性
* 为什么我们不使用公共git分支
* 谁决定ZeroMQ路线图
* 一个`libzmq`更改的实际例子

## ZeroMQ社区的架构 {#Architecture-of-the-ZeroMQ-Community}

你知道ZeroMQ是一个LGPL许可的项目。实际上它是一系列项目的集合，围绕核心库`libzmq`构建。我将这些项目可视化为一个不断扩张的星系：

* 在核心，`libzmq`是ZeroMQ核心库。它用C++编写，具有底层C API。代码很丑陋，主要是因为它高度优化，但也因为它是用C++编写的，这是一种容易产生微妙而深刻丑陋性的语言。Martin Sustrik编写了这部分代码的大部分。今天有几十个人维护它的不同部分。

* 围绕`libzmq`，大约有50个*绑定*。这些是独立的项目，为ZeroMQ创建更高级别的API，或至少将底层API映射到其他语言。绑定的质量从实验性到极其出色不等。可能最令人印象深刻的绑定是[PyZMQ](https://github.com/zeromq/pyzmq)，它是ZeroMQ之上最早的社区项目之一。如果你是绑定作者，你真的应该研究PyZMQ并努力使你的代码和社区一样出色。

* 许多语言都有多个绑定（至少Erlang、Ruby、C#），由不同的人在不同时间编写，或采用不同的方法。我们不以任何方式规范这些。没有"官方"绑定。你通过使用其中一个或另一个、为其贡献或忽略它来投票。

* 有一系列`libzmq`的重新实现，从JeroMQ开始，这是库的完整Java翻译，现在是NetMQ（C#堆栈）的基础。这些本地堆栈提供类似或相同的API，并说与`libzmq`相同的协议（ZMTP）。

* 在绑定之上有很多使用ZeroMQ或基于它构建的项目。查看wiki上的"Labs"页面，了解以某种方式使用ZeroMQ的项目和原型项目的长列表。有框架、像Mongrel2这样的web服务器、像Majordomo这样的代理，以及像Storm这样的企业开源工具。

`Libzmq`、大多数绑定和一些外层项目位于GitHub上的[ZeroMQ社区"组织"](https://github.com/organizations/zeromq)中。这个组织由最资深的绑定作者组成的团体"运行"。要运行的东西很少，因为它几乎都是自我管理的，现在没有任何冲突。

iMatix，我的公司，在社区中扮演特定角色。我们拥有商标并谨慎地执行它们，以确保如果你下载一个自称"ZeroMQ"的包，你可以信任你得到的东西。人们偶尔试图劫持这个名字，可能认为"自由软件"意味着没有财产利益，没有人愿意为其辩护。你从这一章中理解的一件事是我们对软件背后过程的严肃态度（我的意思是"我们"作为一个社区，而不是一个公司）。iMatix通过对任何自称"ZeroMQ"或"ØMQ"的东西执行该过程来支持社区。我们还为软件和打包投入金钱和时间，原因我稍后会解释。

这不是慈善活动。ZeroMQ是一个营利项目，而且是一个非常有利可图的项目。利润广泛分布在所有投资于它的人之间。真的就是这么简单：花时间成为ZeroMQ专家，或在ZeroMQ之上构建有用的东西，你会发现你作为个人、团队或公司的价值在增加。iMatix享受与社区中其他人相同的好处。这对除了我们的竞争对手之外的每个人都是双赢的，他们发现自己面临一个无法击败也无法真正逃脱的威胁。ZeroMQ主导着大规模分布式软件的未来世界。

我的公司不仅支持社区——我们还建立了社区。这是有意的工作；在2007年的原始ZeroMQ白皮书中，有两个项目。一个是技术的，如何制作更好的消息系统。第二个是如何建立一个能够将软件带到主导成功的社区。软件会死，但社区会存活。

## 如何制作真正大型的架构 {#How-to-Make-Really-Large-Architectures}

据说（至少对于大声朗读这句话的人来说），有两种方式来制作真正大规模的软件。选项一是向聪明人的帝国投入大量金钱和问题，并希望出现的不是又一个职业杀手。如果你非常幸运，在大量经验基础上构建，保持团队稳固，不追求技术辉煌，并且还非常幸运，它会成功。

但用他人的数亿资金赌博并非人人都能做到。对于我们其余想要构建大规模软件的人来说，有选项二，即开源，更具体地说是*自由软件*。如果你问软件许可证的选择如何与你构建的软件规模相关，这是正确的问题。

杰出而有远见的Eben Moglen曾经大致说过，自由软件许可证是社区建立的合约。当我大约十年前听到这个时，我想到了一个想法——*我们能够有意地发展自由软件社区吗*？

十年后，答案是"是的"，而且几乎有一门科学。我说"几乎"是因为我们还没有足够的人有意这样做的证据，有文档化、可重复的过程。这就是我试图通过[社会架构](http://cultureandempire.com/cande.html#/4/6)做的事情。ZeroMQ出现在Wikidot之后，在[数字标准组织](http://www.digistan.org)（Digistan）之后，在[自由信息基础设施基金会](http://www.ffii.org)（又名FFII，一个对抗软件专利的NGO）之后。这一切都出现在许多不太成功的社区项目（如Xitami和Libero）之后。我从各种可想象格式的长期项目生涯中得到的主要收获是：如果你想构建真正大规模和持久的软件，要瞄准构建一个自由软件社区。

### 软件架构的心理学 {#Psychology-of-Software-Architecture}

Dirkjan Ochtman让我注意到[维基百科对软件架构的定义](http://en.wikipedia.org/wiki/Software_architecture)是"推理系统所需的结构集合，包括软件元素、它们之间的关系以及两者的属性"。对我来说，这种空洞和循环的行话是我们对成功的大规模软件架构实际构成要素理解得多么可怜的一个好例子。

架构是为人类使用制作大型人工结构的艺术和科学。如果说我在30年制作越来越大的软件系统中学到并成功应用的一件事，那就是：*软件是关于人的*。大型结构本身是无意义的。重要的是它们如何为*人类使用*而发挥作用。在软件中，人类使用从制作软件本身的程序员开始。

软件架构中的核心问题是由人类心理学驱动的，而不是技术。我们的心理学影响我们工作的方式有很多。我可以指出团队似乎随着规模增大或必须跨越更大距离工作而变得愚蠢的方式。这是否意味着团队越小，越有效？那么像ZeroMQ这样的大型全球社区如何设法成功工作？

ZeroMQ社区不是偶然的。它是一个有意的设计，这是我对早期的贡献，当时代码从布拉迪斯拉发的地下室出来。设计基于我的宠物科学"社会架构"，[维基百科将其定义](http://en.wikipedia.org/wiki/Social_architecture)为"有意设计环境以鼓励朝向某个目标或目标集合的期望社会行为范围"。我将此更具体地定义为"规划、设计和发展在线社区的过程和产品"。

社会架构的信条之一是*我们如何组织*比*我们是谁*更重要。同一个团体，以不同方式组织，可以产生完全不同的结果。我们就像ZeroMQ网络中的对等点，我们的通信模式对我们的性能有戏剧性的影响。普通人，良好连接，可以远远超过使用不良模式的专家团队。如果你是更大ZeroMQ应用程序的架构师，你将必须帮助其他人找到正确的协作模式。做对了，你的项目可以成功。做错了，你的项目会失败。

两个最重要的心理要素是我们真的很不善于理解复杂性，而我们非常善于合作来分而治之大问题。我们是高度社会化的猿，有点聪明，但只有在正确的人群中。

所以这是我的软件架构心理要素的简短列表：

* **愚蠢**：我们的心理带宽有限，所以我们在某些时候都是愚蠢的。架构必须简单易懂。这是第一规则：简单性胜过功能性，每一次。如果你不能在一个寒冷灰暗的周一早晨喝咖啡前理解一个架构，它就太复杂了。

* **自私**：我们只出于自身利益行动，所以架构必须为有利于整体的自私行为创造空间和机会。自私往往是间接和微妙的。例如，我会花几个小时帮助别人理解某事，因为这在以后可能对我有价值几天。

* **懒惰**：我们做很多假设，其中许多是错误的。当我们能够用最少的努力获得结果或快速测试假设时，我们最快乐，所以架构必须使这成为可能。具体来说，这意味着它必须简单。

* **嫉妒**：我们嫉妒他人，这意味着我们会克服愚蠢和懒惰来证明他人错误并在竞争中击败他们。因此架构必须为基于任何人都能理解的公平规则的公开竞争创造空间。

* **恐惧**：我们不愿意承担风险，特别是如果它使我们看起来愚蠢。对失败的恐惧是人们顺从并在大规模愚蠢中跟随群体的主要原因。架构应该使静默实验变得容易和便宜，给人们成功的机会而不惩罚失败。

* **互惠**：我们会在艰苦工作方面付出额外代价，甚至金钱，来惩罚作弊者并执行公平规则。架构应该大量基于规则，告诉人们如何一起工作，但不是在什么上工作。

* **顺从**：出于恐惧和懒惰，我们最乐意顺从，这意味着如果模式好、清楚解释和记录，并公平执行，我们每次都会自然选择正确的路径。

* **骄傲**：我们强烈意识到我们的社会地位，我们会努力工作以避免在公开场合看起来愚蠢或无能。架构必须确保我们制作的每一件作品都有我们的名字，所以我们会彻夜难眠地担心别人会对我们的工作说什么。

* **贪婪**：我们最终是经济动物（见自私），所以架构必须给我们经济激励来投资使其发生。也许是磨练我们作为专家的声誉，也许是从某项技能或组件字面意思上赚钱。不管是什么，但必须有经济激励。将架构视为市场，而不是工程设计。

这些策略在大规模上有效，但在小规模上也有效，在组织或团队内部。

### 合约的重要性 {#The-Importance-of-Contracts}

让我讨论一个有争议但重要的领域，即选择什么许可证。我会说"BSD"来涵盖MIT、X11、BSD、Apache和类似许可证，说"GPL"来涵盖GPLv3、LGPLv3和AGPLv3。重要区别是分享任何分叉版本的义务，这防止任何实体捕获软件，从而保持其"自由"。

软件许可证在技术上不是合约，因为你不签署任何东西。但广义上，称其为合约是有用的，因为它承担了各方的义务，并在版权法下使它们在法庭上具有法律约束力。

你可能会问，为什么我们需要合约来制作开源？当然这完全是关于体面、善意、人们为无私动机一起工作。当然"少即是多"的原则在这里适用？更多规则不意味着更少自由？我们真的需要律师告诉我们如何一起工作？对自由和开源软件的快乐公社强加限制性规则集似乎是愤世嫉俗的，甚至是适得其反的。

但关于人性的真相并不那么美好。我们不是真正的天使，也不是魔鬼，只是从十亿年不间断获胜者血统中下来的自利获胜者。在商业、婚姻和集体工作中，迟早我们要么停止关心，要么我们争斗和争论。

换个方式说：集体工作有两个极端结果。要么它是失败、不相关和无价值的，在这种情况下每个理智的人都会走开，不会有争斗。要么它是成功、相关和有价值的，在这种情况下我们开始争夺权力、控制，通常还有金钱。

一个写得很好的合约所做的是保护那些有价值的关系免受冲突。一个预先清楚同意离婚条款的婚姻不太可能以离婚告终。一个双方同意如何解决各种经典冲突的商业交易——比如一方偷走另一方的客户或员工——不太可能以冲突告终。

同样，一个有清楚定义分手条款的写得很好的合约的软件项目不太可能以分手告终。替代方案似乎是将项目沉浸到一个更大的组织中，该组织可以对团队施加压力以一起工作（或失去组织的支持和品牌）。这例如是Apache基金会的工作方式。在我的经验中，组织建设有其自己的成本，最终偏向于更富有的参与者（他们能负担这些有时巨大的成本）。

在开源或自由软件项目中，分手通常采取分叉的形式，社区分成两个或更多团体，每个都有不同的未来愿景。在项目的蜜月期，可能持续数年，没有分手的问题。当项目开始值钱时，或者当主要作者开始疲惫时，善意和慷慨往往会枯竭。

所以在讨论软件许可证时，对于你编写的代码或你使用的代码，一点愤世嫉俗有帮助。问你自己，不是"哪个许可证会吸引更多贡献者？"因为答案在于使命陈述和贡献过程。问你自己，"如果这个项目有一个大争吵，分成三部分，哪个许可证会救我们？"或者，"如果整个团队被一个想要将这个代码变成专有产品的敌对公司收购，哪个许可证会救我们？"

长期生存意味着忍受坏时光，以及享受好时光。

当BSD项目分叉时，它们不能容易地再次合并。实际上，BSD项目的单向分叉是相当系统性的：每次BSD代码最终进入商业项目时，这就是发生的事情。然而，当GPL项目分叉时，重新合并是微不足道的。

GPL的故事在这里是相关的。虽然到1980年代，程序员开放分享代码的社区已经很重要，但他们倾向于使用最小许可证，只要没有真正的金钱参与就能工作。有一个重要的语言栈叫Emacs，最初由Richard Stallman在Lisp中构建。另一个程序员James Gosling（后来给了我们Java）在许多贡献者的帮助下用C重写了Emacs，假设它将是开放的。Stallman得到了那个代码并将其用作他自己C版本的基础。然后Gosling将代码卖给了一个公司，该公司转身阻止任何人分发竞争产品。Stallman发现这种对共同工作的出售极其不道德，并开始开发一个可重用许可证来保护社区免受此类情况。

最终出现的是GNU通用公共许可证，它使用传统版权来强制可重新混合性。这是一个巧妙的技巧，传播到了其他领域，例如摄影和音乐的知识共享。2007年，我们看到了许可证的第3版，这是对微软和其他人对概念的迟来攻击的回应。它已经成为一个长而复杂的文档，但企业版权律师已经熟悉了它，在我的经验中，很少有公司介意使用GPL软件和库，只要边界清楚定义。

因此，一个好的合约——我认为现代GPL是软件的最佳选择——让程序员在没有预先协议、组织或体面和善意假设的情况下一起工作。它使协作变得更便宜，并将冲突转化为健康竞争。GPL不仅定义了分叉时会发生什么，它积极鼓励分叉作为实验和学习的工具。而分叉可能用"更自由"的许可证杀死项目，GPL项目在分叉上茁壮成长，因为成功的实验可以通过合约重新混合回主流。

是的，有许多繁荣的BSD项目和许多死的GPL项目。泛化总是错误的。项目会因为许多原因而兴盛或死亡。然而，在竞争性运动中，人们需要每一个优势。

BSD vs. GPL故事的另一个重要部分是我称之为"泄漏"的东西，这是向底部有小但真实洞的锅里倒水的效果。

### 吃我 {#Eat-Me}

这里有一个故事。它发生在我朋友同事的表兄弟的大哥身上。他的名字曾经是，现在仍然是Patrick。

Patrick是一个计算机科学家，拥有高级网络拓扑的博士学位。他花了两年时间和积蓄构建一个新产品，选择了BSD许可证，因为他相信那会让他获得更多采用。他在阁楼里工作，承担了巨大的个人成本，自豪地发布了他的工作。人们鼓掌，因为它真的很棒，他的邮件列表很快就充满了活动、补丁和愉快的聊天。许多公司告诉他们如何使用他的工作节省数百万。其中一些甚至为咨询和培训付钱给他。他被邀请在会议上发言，并开始收集带有他名字的徽章。他开始了一个小企业，雇了一个朋友和他一起工作，梦想着做大。

然后有一天，有人指给他看一个新项目，GPL许可的，它分叉了他的工作并在改进它。他很恼火和不安，问人们——更不用说是开源同胞！——怎么会如此无耻地偷他的代码。邮件列表上有关于将他们的BSD代码重新许可为GPL代码是否合法的长篇争论。结果是，这是合法的。他试图忽略新项目，但随后他很快意识到来自那个项目的新补丁*甚至不能合并回*他的工作！

更糟的是，GPL项目变得流行，他的一些核心贡献者首先对它做小的，然后做更大的补丁。再次，他不能使用那些更改，他感到被抛弃。Patrick陷入抑郁，他的女朋友离开他去找一个叫做，奇怪的是，Patrice的国际货币交易员，他停止了所有项目工作。他感到被背叛，完全痛苦。他解雇了他的朋友，朋友很糟糕地接受了这件事，告诉每个人Patrick是一个秘密班卓琴演奏者。最后，Patrick在一家云公司找了一份项目经理的工作，到40岁时，他甚至停止了为乐趣编程。

可怜的Patrick。我几乎为他感到难过。然后我问他，"你为什么不选择GPL？""因为它是一个限制性病毒许可证"，他回答。我告诉他，"你可能有博士学位，你可能是我朋友同事的表兄弟的大哥，但你是个白痴，Monique离开你是明智的。你发布你的工作邀请人们请偷我的代码，只要他们在结果工作中保留这个'请偷我的代码'声明"，当人们确实这样做时，你生气了。更糟的是，你是个伪君子，因为当他们秘密做时，你很高兴，但当他们公开做时，你感到被背叛。"

看到你的辛苦工作被一个更聪明的团队捕获然后用来对付你是极其痛苦的，所以为什么要让这成为可能？每个使用BSD代码的专有项目都在捕获它。公开的GPL分叉可能更丢脸，但它完全是自找的。

BSD就像食物。它字面上（我指的是隐喻上）用一个小声音低语"吃我"，人们可以想象一块奶酪坐在世界上最好的啤酒空瓶旁边时可能使用的声音，当然是Orval，由一个古老和几乎灭绝的沉默比利时修士教团酿造，叫做*Les Gars Labas Qui Fabrique l'Orval*。BSD许可证，就像它的近亲MIT/X11，是由一个没有利润动机的大学（伯克利）专门设计来泄漏工作和努力的。它是一种以低于成本价推销补贴技术的方式，希望它能破坏其他人的市场的低价代码倾销。BSD是一个*优秀*的战略工具，但只有当你是一个能够负担使用选项一的大型资金充足的机构时。Apache许可证是穿西装的BSD。

如果这不能说服你，那么让我提出一个关于金钱的论点，因为这是每个人在被骗着在其他人的项目上花费数百小时时最终关心的。时间就是金钱。在一个尚未成为主导力量的专有市场中，BSD项目基本上在帮助其他人赚钱。这是一个慷慨的事情，假设（a）你是慈善机构，或者（b）你会以其他方式获得回报。

但这里是鱼钩。一旦BSD项目赢得一个市场，也就是说，一旦它在一个有价值的空间中获得了大部分份额，那些投资其中的人开始看到这个工作的价值。似乎可能有一个苹果从这棵树上摘取。

这种有价值的工作是如何开发的？它要么基于特殊领域的知识（算法、协议、难题的巧妙解决方案），要么基于大量的投资（编写良好的代码、测试、文档、包装），要么基于一个强大的品牌（建立信任的声誉、许多用户）。让我们假设成功的BSD项目有所有这些。

现在，任何聪明的商人看着这种情况都会想"这些人在向我们倾销他们的工作，以低于其真实成本的价格，甚至免费。他们实际上正在投资我们的business模式。这没有经济意义，除非他们是从政府或大学获得补贴，或者他们非常非常天真。让我们很好地利用它。不仅如此，让我们一劳永逸地杀死可能竞争对手。一旦我们取得了主导地位，我们就能阻止这些人继续倾销，我们就拥有了市场。"

这*确实*发生了，到处都有，BSD许可证是让它发生的工具之一。我现在不太担心BSD，因为它的战略价值明显有限，尽管自我毁灭的倾向很吸引人。选择BSD是在向自己的脚开枪，而一些项目需要学习这个艰难的方式。

但"自由软件许可证允许人们参与一个共同的工作，并共享其价值，而不需要信任或预先协议，同时防止任何一方从共同工作中取得不公平的利益"。

对我们这些将投资像珍贵子弹一样瞄准的小企业来说，工作和努力的泄漏是不可接受的。破坏市场是很好的，但我们不能负担补贴我们的竞争对手。BSD网络栈最终让Windows上了Internet。我们不能负担与那些我们自然应该成为盟友的人的战斗。我们不能负担做出根本的商业错误，因为最终，这意味着我们必须解雇人员。

这归结为行为经济学和博弈论。*我们选择的许可证修改了那些使用我们工作的人的经济学*。在软件行业，有朋友、敌人和食物。BSD让大多数人把我们看作午餐。闭源让大多数人把我们看作敌人（你*喜欢*为软件付钱给人吗？）然而，GPL让大多数人，除了世界上的Patrick们，成为我们的盟友。ZeroMQ的任何分叉都与ZeroMQ许可证兼容，到了我们*鼓励*分叉作为实验的宝贵工具的程度。是的，看到有人试图带着球跑掉可能很奇怪，但这是秘密，*我可以在我想要的任何时候把它拿回来*。

### 流程 {#The-Process}

如果你到现在接受我的论点，太好了！现在，我将解释我们实际构建开源社区的粗略流程。这就是我们如何构建或成长或温和引导ZeroMQ社区存在的。

你作为社区领导者的目标是激励人们出去探索；确保他们可以安全地这样做而不打扰其他人；当他们做出成功发现时奖励他们；并确保他们与其他所有人分享他们的知识（不是因为我们要求他们，不是因为他们感到慷慨，而是因为这是法律）。

这是一个迭代过程。你制作一个小产品，自己承担成本，但在公共视野中。然后你围绕那个产品建立一个小社区。如果你有一个小但真实的成功，社区然后帮助设计和构建下一个版本，并变得更大。然后那个社区构建下一个版本，如此等等。显然你仍然是社区的一部分，甚至可能是主要贡献者，但你试图对材料结果施加的控制越多，人们就越不想参与。在有人决定你是他们的下一个问题之前，好好计划你自己的退休。

### 疯狂、美丽和简单 {#Crazy-Beautiful-and-Easy}

你需要一个足够疯狂和简单的目标来让人们早上起床。你的社区必须吸引最好的人，这需要一些特殊的东西。对于ZeroMQ，我们说我们要制作"最快的。消息传递。曾经。"，这符合一个好的激励者。如果我们说，我们要制作"一个智能传输层，将廉价和灵活地在你的企业中连接你的移动部件"，我们会失败。

然后你的工作必须美丽、立即有用和有吸引力。你的贡献者是想要探索比他们现在的位置稍微远一点的用户。让它简单、优雅和残酷地干净。当人们运行或使用你的工作时的体验应该是情感的。他们应该*感觉*到什么，如果你准确地解决了甚至只是一个大问题，直到那时他们没有完全意识到他们面临，你将拥有他们灵魂的一小部分。

它必须易于理解、使用和加入。太多项目有访问障碍：把自己放在另一个人的思想中，看到他们来到你网站的所有理由，想着"嗯，有趣的项目，但..."然后离开。你想要他们留下并尝试它，只是一次。使用GitHub并把问题跟踪器放在那里。

如果你把这些事情做好，你的社区将是聪明的，但更重要的是，它将在智力和地理上多样化。这真的很重要。一群志同道合的专家不能很好地探索问题景观。他们倾向于犯大错误。多样性任何时候都胜过教育。

### 陌生人，见陌生人 {#Stranger-Meet-Stranger}

两个人需要多少预先协议才能在某事上一起工作？在大多数组织中，很多。但你可以将这个成本降低到接近零，然后人们可以协作而从未见过面，做过电话会议、会议，或商务旅行来讨论角色和责任，喝太多瓶便宜的韩国米酒。

你需要写得很好的规则，这些规则由像我这样愤世嫉俗的人设计，强迫陌生人进入互利协作而不是冲突。GPL是一个好开始。GitHub及其分叉/合并策略是一个好后续。然后你想要像我们的[C4规则书](http://rfc.zeromq.org/spec:22)这样的东西来控制工作实际如何发生。

C4（我现在用于每个新的开源项目）对人们犯的许多常见错误有详细和测试的答案，比如与其他人"因为它更快"在角落里离线工作的罪恶。透明度对获得信任是必需的，这对获得规模是必需的。通过强迫每一个更改通过单一透明流程，你在结果中建立真正的信任。

许多开源开发者犯的另一个大罪是将自己置于他人之上。"我创立了这个项目，因此我的智力优于他人"。这不仅不谦虚和粗鲁，通常不准确，这也是糟糕的生意。规则必须平等适用于每个人，没有区别。你是社区的一部分。你作为项目创始人的工作，不是将你对产品的愿景强加给其他人，而是确保规则是好的、诚实的和*执行的*。

### 无限财产 {#Infinite-Property}

知识业务最悲伤的神话之一是想法是财产的合理形式。这是应该与奴隶制一起被抛弃的中世纪无稽之谈，但遗憾的是它仍在让太多有权势的人赚太多钱。

想法是便宜的。作为财产合理工作的是我们在建立市场中做的艰苦工作。"你吃你杀的"是鼓励人们努力工作的正确模式。无论是对项目的道德权威，从咨询赚的钱，还是向某个大的、富有的公司出售商标：如果你制作它，你拥有它。但你真正拥有的是"客流量"，你项目中的参与者，这最终定义了你的权力。

要做到这一点需要无限的自由空间。谢天谢地，GitHub为我们解决了这个问题，为此我将死一个感激的人（生活中有许多值得感激的理由，我不会在这里列出，因为我们只剩下一百页左右，但这是其中之一）。

你不能像扩展许多小项目的集合那样扩展一个有许多所有者的单一项目，每个都有较少的所有者。当我们拥抱分叉时，一个人可以通过单击成为"所有者"。现在他们只需要通过展示他们独特的价值来说服其他人加入。

所以在ZeroMQ中，我们旨在使在核心库之上编写绑定变得容易，我们停止尝试自己制作这些绑定。这为其他人制作这些、成为它们的所有者并获得那个信用创造了空间。

### 关怀和喂养 {#Care-and-Feeding}

我希望社区可以100%自我引导，也许有一天这会工作，但今天不是这种情况。我们与ZeroMQ非常接近，但从我的经验来看，社区需要四种类型的关怀和喂养：

* 首先，简单地因为大多数人太好，我们需要某种象征性领导或所有者，在冲突情况下提供最终权威。通常是社区的创始人。我看到它与自选的"长老"团体一起工作，但老人喜欢说很多话。我看到社区因为"谁负责？"的问题而分裂，建立有董事会等的法律实体似乎使对控制的争论变得更糟，而不是更好。也许因为似乎有更多要争斗的。自由软件的真正好处之一是它总是可重新混合的，所以而不是为饼而战，人们简单地分叉饼。

* 第二，社区需要活的规则，因此他们需要一个能够制定和写下这些的律师。规则是关键的；当做得对时，它们去除摩擦。当做错或忽视时，我们看到真正的摩擦和争论，可以赶走友好的大多数，让争论的核心负责燃烧的房子。我试图在ZeroMQ和以前的社区中做的一件事是创建可重用的规则，这也许意味着我们不需要律师那么多。

* 第三，社区需要某种财政支持。这是打破大多数船只的锯齿岩石。如果你饿死一个社区，它变得更有创造力，但核心贡献者倦怠。如果你向其中倾注太多钱，你吸引专业人士，他们从不说"不"，社区失去其多样性和创造力。如果你为人们创建一个分享基金，他们会（痛苦地）为此而战。对于ZeroMQ，我们（iMatix）花费我们的时间和金钱在营销和包装（如这本书），以及基本关怀，如bug修复、发布和网站。

* 最后，销售和商业调解很重要。专家贡献者和客户之间有一个自然市场，但两者在相互交谈方面都有些无能。客户假设支持是免费或非常便宜的，因为软件是免费的。贡献者对他们的工作要求公平价格很害羞。这造成了一个困难的市场。我的工作和我公司利润的一个增长部分简单地是连接想要帮助的ZeroMQ用户与能够提供帮助的社区专家，并确保双方对结果满意。

我看到有明亮人才和崇高目标的社区因为创始人在这四件事中的一些或全部犯错而死亡。核心问题是你不能期望任何一家公司、人或团体始终如一的伟大领导。今天有效的往往明天不会有效，然而结构随着时间变得更坚固，而不是更灵活。

我能找到的最佳答案是两件事的混合。一，GPL及其可重新混合性的保证。无论权威多么糟糕，无论他们多么努力私有化和捕获社区的工作，如果它是GPL许可的，那工作可以走开并找到更好的权威。在你说"所有开源都提供这个"之前，想清楚。我可以通过雇用核心贡献者并不发布任何新补丁来杀死BSD许可的项目。但即使有十亿美元，我*不能*杀死GPL许可的项目。二，权威的哲学无政府主义者模式，即我们选择它，它不拥有我们。

## ZeroMQ流程：C4 {#The-ZeroMQ-Process-C}

当我们说ZeroMQ时，我们有时指<tt>libzmq</tt>，核心库。在2012年早期，我们将<tt>libzmq</tt>流程综合成一个正式的协作协议，我们称之为[集体代码构建合约](http://rfc.zeromq.org/spec:22)，或C4。你可以将此视为GPL之上的一层。这些是我们的规则，我将解释每个背后的推理。

C4是GitHub [Fork + Pull模型](https://help.github.com/articles/about-pull-requests/)的进化。你可能会觉得我是git和GitHub的粉丝。这会是准确的：这两个工具在过去几年对我们的工作产生了如此积极的影响，特别是在建立社区方面。

### 语言 {#Language}

> 这个文档中的关键词"必须"、"不得"、"必需"、"应当"、"不应当"、"应该"、"不应该"、"推荐"、"可以"和"可选"要按RFC 2119中描述的那样解释。

## 社区的进化 {#The-Evolution-of-Community}

所以我们有了为什么GPL为大规模社区合作创造了最佳激励结构的经济理论。坦率地说，这比理论更多的是经验。十年来构建ZeroMQ社区，我逐渐学会了什么有效，什么无效。我试图将最佳实践打包成可重用的流程。

在iMatix，我们以前没有为我们的开源项目获得多少社区。我们有一些坚定的用户，一些偶尔的补丁，当我们向世界宣布一个新版本时非常少的兴奋。我们的Xitami web服务器应该已经击败了Apache在其游戏中。我们拥有所有更好的技术。但Apache获得了软件历史上最有价值的用户社区之一，我们得到了...呃...在开源世界中什么都不是的roundroundabout。

当我们开始ZeroMQ项目时，我有几个具体目标。首先，我想创建一个协作"边缘"，这意味着有兴趣在其上构建的人们无需先找我们商量。我想要ZeroMQ有一个明确而深思熟虑的架构，人们可以轻松地扩展。

其次，我想要一个基于真正自由软件许可证的大型、多样化的贡献者社区。我想要在代码中拥有部分所有权的数百人。我想要自包含的项目，人们可以独立工作，做出自己的发布和成功决定。

第三，我想要用软件赚钱。我不是在做慈善。我想要一个为包括我在内的所有人都有利可图的business模式。

最后，我想要推翻现有的消息传递玩家。那时是IBM、微软、Red Hat和TIBCO。我们有更好的技术，但我们是一个由五个人组成的私人公司与billion美元企业竞争。只有通过某种魔法，我们才能成功。在我看来，那个魔法称为"社区"。

### 真正解决问题 {#Actually-Solving-Problems}

第一个基本因素是我们投资了数百万美元和多年时间来真正解决底层问题。好的软件开始于实际的疼痛。如果你试图解决一个*假*问题，你将无法构建一个产品人们真正想要的社区。

我认为99%的失败的开源项目没有解决真正的问题，或者解决了太特定于某个特定领域的问题。你需要能够以冷静、客观的术语陈述问题。"消息传递太复杂和昂贵"是一个好问题。"这个其他项目不是用我最喜欢的编程语言编写的"是一个坏问题。

### 识别敌人 {#Identifying-the-Enemy}

第二个因素是敌人的存在。为了建立一个强大的社区，你需要一个明确可识别的敌人，大到足以使攻击它显得勇敢和英勇，却又确实脆弱。最好的敌人是一个垄断者，因为垄断者倾向于停滞和自满。当我们开始时，我们的敌人是企业消息传递供应商。我们的竞争优势非常清楚：我们是更快、更便宜、更开放的。

### 广阔的竞争空间 {#A-Broad-Competitive-Space}

第三个因素是解决方案空间的规模。如果你正在解决一个具有单一、明显、正确答案的问题，那么将没有竞争空间，人们会争夺是否包含这个答案。一个好的大问题有数百个令人兴奋的部分解决方案，每个都有不同的边界。ZeroMQ做到了，因为消息传递是一个出奇深的领域。一个典型的想法是"让我们制作一个包装libzmq的移动库"。

### 强烈的简单性取向 {#A-Strong-Orientation-to-Simplicity}

第四个因素是对简单性的关注。这意味着可以被理解和被很多人轻易采用的架构。这种简单性首先来自于解决真正*最小*的问题，以这样一种方式构建解决方案，即人们可以将其组合成更大的解决方案。

ZeroMQ花了几年才到达这个点。最初，我们制作了一个典型的"厨房水槽"式消息传递产品。它需要配置文件来正确设置。它无法与现有代码正确集成。我们反复撕碎这个设计，去除概念和特性，直到我们到达了在《指南》的前几章中看到的最小概念集合。

### 残酷的流程 {#Brutal-Process}

过程最终是有机社区和平面公司之间的区别。一个好的流程平衡了每个人的需求。一个坏的流程更偏向某些人（通常是那些制定流程的人）并驱散其他人。

我已经解释了我们在其他项目中的挫折。ZeroMQ的C4流程是我对我认为在《指南》的前几章中看到的最小概念集合的最终概念的简化努力的数年简化努力的结果。它让ZeroMQ蓬勃发展。让我们看看它是如何工作的。

## 集体代码所有权合约（C4） {#The-Collective-Code-Construction-Contract-C4}

### 序言 {#Preamble}

C4旨在为开源软件项目提供一个最优协作模型。它有这些具体目标：

1. 最大化解决问题的规模和多样性；
2. 减少参与障碍对新贡献者的影响；
3. 通过允许安全实验、快速失败和隔离稳定代码，支持项目版本从实验到稳定的自然生命周期；
4. 减少项目仓库的内部复杂性，从而更容易让贡献者参与并减少错误范围；
5. 强制项目的集体所有权，这增加了对贡献者的经济激励并减少了被敌对实体劫持的风险。

### 许可和所有权 {#Licensing-and-Ownership}

项目应使用GPLv3或其变体（LGPL、AGPL）。

为什么对许可证如此教条？因为共享、混合和重新混合是ZeroMQ社区的核心，而GPL在这方面是无与伦比的。我们尝试过LGPL，效果很好。BSD在这方面太弱了，不能让社区粘在一起。

项目应使用相同的许可证拥有所有贡献。

这意味着我们拥有（作为一个集合）项目的整个代码库。没有单一的公司或个人可以威胁社区说"这是我的代码，你们必须用我的方式做事，否则我就拿走它"。我们看到这种情况在那些允许人们贡献而不分享所有权的项目中发生。

维护者不应要求更改贡献的许可证或所有权，除非贡献者明确同意这样做。

换句话说，如果你向一个C4项目贡献代码，你立即而自动地获得在整个代码库中的份额，而我们也获得在你贡献中的份额。维护者（经常是公司）不能故意收集版权，除非每个贡献者明确同意这样做。

项目应具有公开记录的贡献者，包括他们的真实姓名和电子邮件地址。

在C4项目中，我们在COPYRIGHT或AUTHORS文件中明确记录每个贡献者。这样，每个人都可以看到他们作为作者的股份，并联系其他人。我们使用真实姓名和联系信息，因为匿名不创建问责制。

### 补丁要求 {#Patch-Requirements}

维护者和贡献者必须具有执行合约条款的平台账户。

这通常意味着GitHub账户。

补丁应该是对单一可识别问题的最小且准确的答案。

一个补丁不应混合不同的关注点。如果我修复两个不同的bug，我会制作两个补丁。

补丁必须遵守项目的代码风格指南，如果这些已定义。

这是一个"如果"，因为许多项目没有编码标准。当你编写代码时，尝试模仿你看到的风格，以及当有人批评你的风格时，学习要求什么。

补丁必须遵守项目定义的"贡献指南"，如果这些已定义。

同样，这些可能存在或不存在。然而，如果某些类别的补丁被拒绝，必须有关于这一点的明确文档。贡献指南也应该解释如何实际向项目提交补丁。

补丁不应包含非琐碎代码，除非贡献者是原始作者。

这是防止人们贡献专有代码或他们没有清楚权利的其他代码的保障。琐碎意味着在实现方式上没有创造性。

补丁必须编译干净并通过项目自测试至少在开发者的盒子上。

每个项目应该有自测试。至少，C项目应该使用像Travis或Buildbot这样的系统，在每次提交或拉取请求时，自动构建和运行测试。

### 开发过程 {#Development-Process}

更改项目必须由贡献者以补丁形式进行。

"更改"可能是bugfix、新特性、文档改进，或其他任何东西。术语"开发者"在这里具有误导性，因为它暗示一些特殊类别的人。相反，任何人都可以向ZeroMQ贡献。

贡献者应该尝试尽可能少地进行更改，一次一个。

这极大地简化了代码审查和测试，并减少了大补丁破坏构建或引入微妙bug的机会。

贡献者不应提交对不稳定或不完整功能的更改。

也就是说，请勿故意破坏构建或添加不起作用的代码。这是常识，但我仍然看到人们在自己的分支上正常工作，然后向主仓库发送一个包含几个broken提交的拉取请求。每次提交应该可用，至少在开发者的系统上。

维护者应将正确的补丁迅速合并到项目中。

"迅速"的定义很难。在libzmq中，通常是在24小时内。但这确实取决于（a）补丁的复杂性，以及（b）维护者和贡献者之间建立的信任级别。新贡献者的新补丁可能需要更长时间才能通过，这是为了学习和建立信任。建立的贡献者的熟悉补丁应该非常快地合并。

如果贡献者坚持所有补丁规则，维护者不应合并自己的补丁。

即使你是项目的维护者，你仍然必须遵循相同的流程，作为其他人。没有特殊案例，除了也许非常琐碎的更改，如错别字，可以在没有拉取请求的情况下进行。

如果贡献者满足上述要求，维护者不应有不合并补丁的主观判断。

这是C4的核心。它首先在PyZMQ项目中使用，并证明是一个巨大的成功。任何补丁，只要它遵循上述条件，就必须被合并。维护者不能说"我不喜欢这个特性"或"这个与我对未来的想法不符"或"这个太复杂"。无论个人感受如何，技术上正确的补丁应该被合并。

维护者应要求对不正确的补丁进行改进，并应在尝试几次后拒绝不正确的补丁。

注意我们如何将不正确的补丁与我们不喜欢的补丁区分开。不正确的补丁是不工作的、破坏构建的、或明显违反项目约定的补丁。在这种情况下，维护者首先要求改进。"嘿，这个补丁破坏了构建在Windows上，你能修复吗？"如果贡献者无法或不会修复问题，最终补丁被拒绝。在libzmq中，我们尝试在拒绝之前帮助困难的补丁。

任何贡献者可以充当维护者。

当然，有些人比其他人有更多时间，而某些项目限制谁可以实际合并补丁。但能力是关键，不是权威。

维护者不应对同一问题提出竞争补丁。

如果你认为贡献者的补丁解决问题的方式不正确，说明你的案例，让他们修复它。如果他们不能或不愿，那么你可以展示你自己的"正确"解决方案。竞争性开发和每个人都想要成为最聪明的人是毒性的。

项目可以有多个维护者来处理不同的领域。

特别是在大项目中，你会想要多个维护者，不同的人关心项目的不同部分。

任何协作者可以成为维护者，通过准确判断其他贡献者的补丁。

也就是说，维护者不是由某些大祭司任命的，他们通过实际做好工作而成为维护者。在实践中，如果你是一个积极的用户或贡献者，并且你开始评论其他人的补丁，你就是一个维护者。

贡献者可以通过公开投诉撤回自己的错误。

即，如果你合并了一个补丁，并且其他人投诉它破坏了某些东西，然后你（或他们）应该撤回它，直到问题得到解决。

维护者应回应所有补丁，正确与否。

既然贡献者承诺准确编码，维护者也应承诺及时回应。无声的维护者对项目是毒性的。注意，这意味着在实践中，你将无法维护一个非常流行的项目。这里的数学是残酷的：用户数量和补丁数量线性增长，而维护者时间是固定的。一个成功的项目会越来越依赖更多的维护者，以及自动化测试。

维护者可以与其他协作者讨论补丁，然后再接受或拒绝。

谈论补丁是好的；这通常是教学和学习发生的地方。

贡献者可以标记问题为"准备"或等同，表示愿意开始在该问题上工作。

我们使用GitHub问题跟踪器，让人们识别并讨论问题。有点像维基百科，"问题"的定义是相当宽的。

要在问题上工作，贡献者应分叉项目库并独立工作。

这是GitHub模型的强制项目分叉方法，因为贡献者无法向主项目推送。在实践中，你分叉项目，制作补丁，向原始项目提交拉取请求，然后删除你的分叉，除非你想继续在项目上工作。

贡献者应在问题最小可测试解决方案。

这通常意味着一个测试案例加上解决问题的代码。如果问题不能被测试，那么应该有一个可验证的案例，其他人可以运行它以说"是的，这修复了问题"。

贡献者不应在同一项目分支上提交多个补丁。

每个补丁应该在其自己的分支上，制作一个干净的拉取请求。如果你在其他补丁等待接受时开始处理第二个补丁，创建一个新分支。最佳实践是从主分支创建每个新补丁分支，而不是从你现有的补丁分支。这样，如果一个补丁被拒绝，其他的不会被阻塞。

项目可以有和使用超级维护者，他们代表项目做最终决定。

这是避免分叉的逃生路线。如果维护者无法就是否应该合并特定补丁达成一致，超级维护者决定。在libzmq中，我们确实有这种，它偶尔使用过，总是结果是正确的补丁被合并。

这就是整个C4流程。

### 分支和发布 {#Branching-and-Releases}

项目应有且仅有主分支（"master"），对所有用户始终可构建。

这是关键的"git使分支易于使用"反模式。虽然git使分支变得容易，但git分支对人们来说根本不容易。还有一个问题，即一旦你制作了分支，你会自动创建一个"何时以及如何将东西重新合并回master"的问题。避免分支意味着避免合并，这也意味着消除一整类错误和潜在的争论。

维护者应将补丁标记为稳定版本。

当你想要制作稳定版本时，你拿当前master并标记它（在git中）为版本。你永远不应该在分支上制作稳定版本。

项目可以在任何时间点制作实验性发布，从master分支。

另一个反模式是你有"开发"分支和"稳定"分支的地方。这结果只是缓慢地破坏master分支，然后让人们直接推送到它。反过来，我们所做的是始终保持master可构建和稳定，并制作实验版本（标记为"alpha"或"beta"）尽可能频繁。

项目应有版本化发布，并且每个版本应该具有唯一数字或名称。

你的用户需要知道他们在运行什么。我知道这很明显，但我见过它被忽略的项目。标记版本，并为它们赋予清楚名称或数字，例如"v2.2.8"或"2013/01/15"（我更喜欢在一开始时使用日期）。

项目应为新贡献者记录新版本中的重要更改。

用户喜欢好的发布说明。不要删除行动，描述所有重要更改，特别是向后兼容性的中断。

### 进化特性 {#Evolution-of-Specifications}

项目可以有规范协议或API的规范文档。

通常对于库，API _是_ 规范。对于协议，你将想要明确的规范文档。我们在ZeroMQ中有详细的协议规范，这使我们能够构建互操作库。

规范文档可以进化的同一个速度和方式如项目源代码。

这意味着当我们更改代码时，我们也更新规范。我们让git为我们跟踪规范更改，就像代码更改一样。

维护者或贡献者可以更改规范以解决新问题。

有一个常见的反模式，即规范是设计在真空中，然后实现。这从不有效。相反，我们识别问题，然后解决它们，既在代码中也在规范中。

新规范可以标记为"草案"，直到在一定时间内证明稳定。

通常我们制作C4规范（这是规范），然后当它们已经被两个或更多互操作实现实现并证明稳定至少六个月时标记它们为"稳定"。

旧规范不应被删除或修改，除非在最终用户中造成问题。

像代码一样，规范应该积累，不是经历"重构"，这只是破坏用户的一种好方式。

当旧和新规范冲突时，新规范应优先考虑标记为弃用旧规范。

有时需要做这样的破坏性更改。我们尽量避免它们，但当我们这样做时，我们小心地解释变化和时间表。

新规范应寻求向后兼容旧规范。

再次，这是避免破坏现有用户代码的策略。

## 一个真实的例子 {#A-Real-Example}

Michiel Gerbino制作了一个libzmq的拉取请求，其中添加了一个新的套接字选项ZMQ_DELAY_ATTACH_ON_CONNECT。 下面是实际的拉取请求和讨论，展示了C4实际运行的情况。注意维护者如何询问具体改进，以及贡献者如何回应。整个过程从开始到最终合并花了大约两个小时。

我注意到一些有趣的点：

* 这是一个小的、最小的解决特定问题的补丁。
* 贡献者在解释变更时非常清楚。
* 维护者要求改进（测试案例），这个要求是具体和理智的。
* 没有讨论补丁的*目的*，只有技术。
* 一旦补丁技术上是正确的，它立即被合并。

这是我在libzmq中看到的典型交互，一天几次。

## 编写跨平台C代码 {#Writing-Cross-Platform-C-Code}

如果你要为ZeroMQ贡献C代码，你需要知道平台可移植性的一些规则。C不是真正的跨平台语言，如Java或C#。它更像是一个半可移植汇编器。但这给了它一些独特的力量：你可以解决任何计算问题，可以与任何其他软件堆栈交谈，并且，如果你小心，可以创建快速和紧凑的代码，可以在任何地方运行。

本节总结了我们用于ZeroMQ的可移植性规则，基于我们支持平台上十五年的经验。

### 没有编译器扩展 {#No-Compiler-Extensions}

ZeroMQ代码不能使用编译器扩展。它非常纯粹的ISO C90，除了两个特定的C99扩展在极少数地方我们使用它们（具体是长长整数类型和可变参数宏）。当然，系统头文件经常使用编译器扩展，但应用程序代码不应。

### 没有Windows版本假设 {#No-Windows-Version-Assumptions}

我们不假设Windows的具体版本。如果某些功能需要Windows版本检查，它需要在运行时检查，而不是编译时。这意味着可执行文件将运行在较旧版本的Windows，只要它们不尝试使用不受支持的功能。

### 没有内联函数 {#No-Inline-Functions}

某些编译器不支持内联函数。相反，我们使用预处理器宏。

### 没有外部依赖关系 {#No-External-Dependencies}

"安装libzmq"应该不需要首先安装任何其他包，除了在某些情况下OpenPGM（可选）。特别地，ZeroMQ从不依赖于其他ZeroMQ库，APR，Boost，或类似的"帮助"库。

### 标准整数类型 {#Standard-Integer-Types}

在C90中，"int"和"long"类型模糊定义的，表示"机器运算的自然尺寸"。在64位机器上这可能是64位，但在嵌入式系统上可能是16位。在libzmq中，我们从不使用这些类型。我们使用明确大小的类型。在较老的编译器中，我们定义这些：

{{< textdiagram name="standard-integer-types" >}}
typedef unsigned char byte;
typedef unsigned short uint16_t;
typedef unsigned long uint32_t;
typedef short int16_t;
typedef long int32_t;
{{< /textdiagram >}}

以及用于某些特定使用的几个其他类型：

{{< textdiagram name="other-types" >}}
typedef unsigned long size_t;
typedef long ssize_t;
{{< /textdiagram >}}

### 避免名称冲突 {#Avoiding-Name-Clashes}

我们的公共API在所有符号前加前缀"zmq_"。我们的私有API和全局符号前加前缀"zmq_"后跟库名和下划线。例如，在libzmq中我们使用"s_"代表静态函数。

### 可移植时间函数 {#Portable-Timing-Functions}

虽然POSIX定义了一些很好的时间函数，它们在Windows上不存在。我们提供可移植包装器，它们可以精确到毫秒，对于ZeroMQ已经足够：

{{< textdiagram name="portable-timing" >}}
//  将现在的时间作为毫秒返回
uint64_t zmq_clock_time (void);

//  睡眠几毫秒
void zmq_clock_sleep (int msecs);
{{< /textdiagram >}}

使用本地时钟来计算相对时间差，但从不计算绝对时间或日期，也不在线程或进程之间比较时钟值。

### 国际化文本处理 {#Internationalized-Text-Processing}

所有用户可见文本应使用UTF-8编码，包括printf语句中的字符串常量。字符串长度是字节数，不是字符数。我们不执行任何特定的国际化，如整理。

### 多线程模式 {#Multithreading-Pattern}

我们使用线程非常保守。一个ZeroMQ应用程序应该能够在单线程进程中愉快地工作。我们的一般模式是运行单独的线程，通过锁的信号或数据结构进行通信。

我们从不分享状态，除了使用zmq_atomic_counter_t类型，我们为它提供可移植实现。我们从不使用互斥体，事件，或信号量。我们从不进行阻塞线程间调用。

一个库可以创建线程，但这些必须完全隐藏于用户。如果用户想要利用多个线程，他们会自己创建这些。

我们通过使用zmq_thread_create、zmq_thread_close方法提供可移植的线程。我们不提供线程取消，因为这导致难以调试的代码。

### 信号 {#Signals}

我们不捕获或发送信号。

### 可移植套接字 {#Portable-Sockets}

对于网络I/O我们使用标准BSD套接字，在Windows和POSIX之间有区别。我们从不使用在某些平台上不可用的更高级API，如poll()或epoll()。我们隐藏套接字I/O不一致性，使用类型和宏：

{{< textdiagram name="portable-sockets" >}}
typedef int zmq_fd_t;           //  套接字文件描述符类型
#define ZMQ_INVALID_SOCKET -1   //  无效套接字
{{< /textdiagram >}}

### 内存管理模式 {#Memory-Management-Pattern}

ZeroMQ不暴露其内存分配策略。可见的对象是句柄（不透明指针），你创建使用xxxx_new()方法并删除使用xxxx_destroy()方法。我们从不在API中使用不透明结构。

C没有"new"和"destroy"关键字，所以使用create/destroy，或new/destroy，或new/free是风格问题。我们更喜欢new/destroy模式作为更安全（各种C运行时有不同的free()方法，但只有一个模式用于分配器析构器）。

### 标准I/O和打印 {#Standard-I-O-and-Printing}

我们不执行任何控制台I/O，除了在断言失败的情况下（这被写到stderr）。

## 贡献一个补丁到ZeroMQ {#Contributing-a-Patch-to-ZeroMQ}

让我示范一个完整的补丁，从开始到结束，从识别问题到提供已工作的解决方案。我实际上需要这个补丁，大概在我写这一段的时间前约一个小时，所以它是真实的。它是libzmq库的问题，它实际应该能够加载超过255个套接字。

### 1. 检查问题是否已知 {#Check-the-Issue-is-Not-Already-Known}

我第一次去了[ZeroMQ Jira](https://zeromq.jira.com)并搜索现有问题。有些但不是我需要修复的那个。

### 2. 创建一个最小测试案例 {#Create-a-Minimal-Test-Case}

我写了最小C程序来重现问题：

{{< examples name="ping" title="Demonstrate the problem" >}}

我首先运行这个来确认问题（它在大约300个套接字后崩溃）。然后我将其作为gist发布并记录精确的错误（打开太多文件）。

### 3. 为问题制作问题案例 {#Make-an-Issue-Case-for-the-Problem}

我在[GitHub ZeroMQ问题页面](https://github.com/zeromq/libzmq/issues)上提交了问题。我给它一个清楚的标题，并解释问题，带测试案例和预期结果。

### 4. 分叉libzmq库 {#Fork-the-libzmq-Repository}

我去了[libzmq](https://github.com/zeromq/libzmq)并单击了"Fork"按钮。

### 5. 克隆我的分叉到我的笔记本电脑 {#Clone-My-Fork-to-My-Laptop}

{{< textdiagram name="clone-fork" >}}
git clone git@github.com:hintjens/libzmq.git
{{< /textdiagram >}}

### 6. 制作一个修复补丁 {#Make-a-Patch-That-Fixes-the-Problem}

这部分取决于问题。在我的情况下，我在自动构建测试中添加了一行，自动测试大量套接字。

我在一个分支上制作了这个：

{{< textdiagram name="make-branch" >}}
git branch --track pingpong origin/master
git checkout pingpong
//  编辑文件，提交更改
git commit -a -m "Solution to LIBZMQ-777 - set FD_SETSIZE to 16384"
{{< /textdiagram >}}

我一直在重复这个，直到解决方案编译并通过自测试。

### 7. 测试修复 {#Test-the-Fix}

我回到原始的问题测试案例并确认问题已修复。

{{< textdiagram name="test-fix" >}}
cd libzmq
make
gcc -I include ping.c -o ping .libs/libzmq.a
./ping
{{< /textdiagram >}}

实际上我首先让libzmq无法构建，那是因为autoconf缓存。所以我从头重新构建：

{{< textdiagram name="rebuild" >}}
make distclean
./autogen.sh
./configure
make
{{< /textdiagram >}}

### 8. 将补丁推送到我的GitHub fork {#Push-the-Patch-to-My-GitHub-Fork}

{{< textdiagram name="push-patch" >}}
git push origin pingpong
{{< /textdiagram >}}

### 9. 制作GitHub拉取请求 {#Make-a-GitHub-Pull-Request}

我去了我在GitHub上的libzmq fork，选择了pingpong分支，并制作了一个拉取请求。

### 10. 等待 {#Wait}

根据时区和一天的时间，这可能需要几分钟到几天的时间来获得维护者的响应。

## ZeroMQ RFC流程 {#The-ZeroMQ-RFC-Process}

如果你仔细想想，一个明智的维护者不会轻易接受可能破坏稳定的新特性。仅仅因为你对某些新功能有疯狂的想法，并不意味着我们会把它合并到ZeroMQ核心中。新特性提出了维护成本，并且它们可能使软件对新用户来说太复杂。

请看我们解决此问题的方法。对于新的协议和新的API，我们要求你写一个RFC（意见征求稿）。我们有一个[网站](http://rfc.zeromq.org)，你可以在那里提交新的RFC。RFC解释了问题、提出了解决方案，并提供了参考实现。这样维护者不必猜测你的补丁真正意图做什么。

我们在几个层面使用RFC流程：

* 对于libzmq的新API特性
* 对于新的协议
* 对于新的ZeroMQ问题检测和解决方法
* 对于我们正在考虑的流程更改

RFC流程确保：

* 我们记录了我们要解决的确切问题
* 我们记录了我们的解决方案
* 有一个参考实现可以测试
* 社区中的其他人可以对此提供反馈

虽然你可以向libzmq发送补丁而不先写RFC，但如果你想添加新特性，维护者可能会要求你先写一个。

下面是一个示例，展示了我刚刚对libzmq进行的重要更改。这不是为了修复问题（修复问题总是欢迎的），而是为了添加新特性。新特性需要解释和文档，或者它们会被拒绝。

案例是有人告诉我，"需要一种方法来捕获最后值缓存代理中的所有订阅。XSUB过滤了重复项，所以我们失去了信息。"这确实是一个真实的问题。在第5章的克隆模式中，我们看到了一个最后值缓存代理。现在，这个代理可以看到订阅，这些由XSUB向上游传递。但XSUB过滤重复项，所以如果客户端订阅相同的话题两次，代理看不到第二个订阅。

如果我们想要统计客户端订阅某个主题的次数，我们需要XSUB传递所有订阅，而不仅仅是独特的。

我回应说："让我们对此进行RFC",并创建了[ZeroMQ RFC 26](http://rfc.zeromq.org/spec:26)。当我写这个RFC时，我意识到这应该是一个新的套接字选项ZMQ_XPUB_VERBOSE。

现在，我想到的第一个解决方案不是最佳的，并且在与一些其他ZeroMQ专家交谈后，我们意识到套接字选项应该在XPUB而不是XSUB套接字上。

当你写一个RFC时，它确实在你的头脑中澄清问题和解决方案。还可以让其他人批评和改进它。所以我更新了RFC以反映更好的解决方案。

实际实现很简单。XPUB套接字已经从下游的SUB套接字接收订阅，并在将它们传递给上游之前过滤重复项。

所以，现在是时候向<tt>xpub.hpp</tt>中的<tt>xpub</tt>类定义添加一个私有属性了：

```
// 如果为真，向上游发送所有订阅消息，而不仅仅是独特的
bool verbose;
```

然后从<tt>router.cpp</tt>中提取一些代码来实现<tt>xsetsockopt</tt>方法。最后，更改<tt>xread_activated</tt>方法以使用这个新选项，同时让对套接字类型的测试也更加明确：

```
//  如果订阅不是重复的，则存储它，以便在下次recv调用时使用。
if (options.type == ZMQ_XPUB && (unique || verbose))
    pending.push_back (blob_t (data, size));
```

代码第一次构建得很好。这让我有点怀疑，但由于懒惰和时差反应，我不会立即创建一个测试案例来实际尝试这个更改。流程不要求这样做，即使通常我会这样做只是为了抓住我们所有人犯的那不可避免的10%的错误。但是，我确实在<tt>doc/zmq_setsockopt.txt</tt>手册页面上记录了这个新选项。在最坏的情况下，我添加了一个并不真正有用的补丁。但我肯定没有破坏任何东西。

我没有实现匹配的<tt>zmq_getsockopt</tt>，因为"最小化"意味着说到做到。对于获得你大概刚刚在代码中设置的选项值，没有明显的用例。对称性不是将补丁大小加倍的有效理由。我确实必须记录新选项，因为流程说："所有公共合约都应该被记录。"

提交代码，我将补丁推送到我的分叉存储库（"origin"）：

```
git commit -a -m "Fixed issue #443"
git push origin master
```

切换到GitHub Web界面，我转到我的<tt>libzmq</tt>分叉，并按顶部的大"Pull Request"按钮。GitHub要求我输入标题，所以我输入"Added ZMQ_XPUB_VERBOSE option"。我不确定为什么它问这个，因为我做了一个整洁的提交消息，但嘿，让我们随波逐流。

这产生了一个很好的小拉取请求，有两个提交；一个是我一个月前在发布说明上做的，为v3.2.1发布做准备（当你大部分时间在机场度过时，一个月过得如此之快），以及我对问题#443的修复（37行新代码）。GitHub让你在启动拉取请求后继续进行提交。它们会排队并一次合并。这很容易，但维护者可能会基于一个看起来无效的补丁拒绝整个包。

因为Dan正在等待（至少在我高度乐观的想象中）这个修复，我回到zeromq-dev列表并告诉他我已经做了补丁，附上提交的链接。我越快得到反馈，越好。当我制作这个补丁时，韩国时间是凌晨1点，所以在欧洲是傍晚，在美国是早上。当你与世界各地的人一起工作时，你学会计算时区。Ian在开会，Mikko在登飞机，Chuck可能在办公室，但三个小时后，Ian合并了拉取请求。

在Ian合并拉取请求后，我将我的分叉与上游<tt>libzmq</tt>存储库重新同步。首先，我添加一个*remote*，告诉git这个存储库位于何处（我在我工作的目录中只做一次）：

```
git remote add upstream git://github.com/zeromq/libzmq.git
```

然后我从上游master拉取更改并检查git日志以双重检查：

```
git pull --rebase upstream master
git log
```

这基本上就是为了向<tt>libzmq</tt>贡献补丁需要学习和使用的git数量。六个git命令和一些网页上的点击。对我作为一个天生懒惰、愚蠢、容易混乱的开发者来说最重要的是，我不必学习git的内部模型，也永远不必做任何涉及我们称为"git分支"的那些地狱般的结构复杂性引擎的事情。接下来，尝试暗杀git分支。让我们活得危险点！

## Git分支被认为是有害的 {#Git-Branches-Considered-Harmful}

Git最受欢迎的特性之一是它的分支。几乎所有使用git的项目都使用分支，选择"最佳"分支策略就像开源项目的成人礼。Vincent Driessen的[git-flow](http://nvie.com/posts/a-successful-git-branching-model/)可能是最知名的。它有*基础*分支（master、develop）、*特性*分支、*发布*分支、*热修复*分支和*支持*分支。许多团队已经采用了git-flow，甚至有git扩展支持它。我是大众智慧的忠实信徒，但有时你必须认识到大众妄想是什么。

这是C4的一个部分，当你第一次读到它时可能会震惊你：

> 项目不应出于任何原因使用主题分支。个人分叉可以使用主题分支。

明确地说，我谈论的是*共享存储库中的公共分支*。使用分支进行私人工作，例如处理不同问题，似乎工作得足够好，尽管这比我个人喜欢的复杂性更多。再次引用Stallman："你创造复杂性的自由在距离我们共享工作空间一英寸处结束。"

像C4的其余部分一样，分支规则不是偶然的。它们来自我们制作ZeroMQ的经验，从Martin Sustrik和我重新思考如何制作稳定发布开始。我们都喜爱和欣赏简单性（有些人似乎对复杂性有非凡的容忍度）。我们聊了一会儿...我问他，"我要开始制作稳定发布。我在你正在工作的git中制作一个分支可以吗？"Martin不喜欢这个想法。"好吧，如果我分叉存储库，我可以将补丁从你的存储库移到那个存储库。"这对我们两个都感觉好得多。

ZeroMQ社区中许多人的反应是震惊和恐惧。人们觉得我们懒惰，并让贡献者更难找到"正确的"存储库。尽管如此，这似乎很简单，确实它工作得很顺利。最好的部分是我们每个人都按我们想要的方式工作。而之前，ZeroMQ存储库感觉可怕地复杂（甚至不像git-flow），这感觉简单。而且它工作了。唯一的缺点是我们失去了单一的统一历史。现在，也许历史学家会感到被抢劫，但我诚实地看不出包括每个分支和实验在内的谁在何时更改了什么的历史细节，值得任何重大痛苦或摩擦。

人们已经习惯了ZeroMQ中的"多存储库"方法，我们已经开始在其他项目中相当成功地使用它。我自己的观点是历史会判断git分支和像git-flow这样的模式是对从Subversion和单片存储库时代继承的想象问题的复杂解决方案。

更深刻地，也许这就是为什么大多数似乎是"错误的"：我认为分支与分叉的争论实际上是关于如何最优制作软件的更深层次的设计与演化争论。我将在下一节中解决那个更深层次的争论。现在，我将尝试通过查看许多标准，并在每个标准中比较分支和分叉，对我对分支的非理性仇恨进行科学分析。

### 简单性与复杂性 {#Simplicity-Versus-Complexity}

*越简单越好。*

分支本质上没有比分叉更复杂的理由。然而，git-flow使用*五种类型*的分支，而C4使用两种类型的分叉（开发和稳定）和一个分支（master）。因此，间接证据表明分支比分叉导致更多复杂性。对新用户来说，绝对是，我们在实践中测量过这个，学习使用许多存储库而没有除master之外的分支更容易。

### 变更延迟 {#Change-Latency}

*交付越小越快越好。*

开发分支似乎与大型、缓慢、风险交付强烈相关。"抱歉，我必须在我们测试新版本之前合并这个分支"表明流程的崩溃。这肯定不是C4的工作方式，C4通过紧密专注于个别问题及其最小解决方案来工作。在开发中允许分支增加变更延迟。分叉有不同的结果：分叉者有责任确保他的更改干净地合并，并保持它们简单，这样它们不会被拒绝。

### 学习曲线 {#Learning-Curve}

*学习曲线越平滑越好。*

证据明确显示学习使用git分支是复杂的。对某些人来说，这没问题。对大多数开发者来说，每个花在学习git上的周期都是在更有成效的事情上失去的周期。我被几个不同的人告诉过几次，我不喜欢分支因为我"从未正确学习git"。这是公平的，但这是对工具的批评，不是对人的。

### 失败成本 {#Cost-of-Failure}

*失败成本越低越好。*

分支要求开发者更完美，因为错误可能影响其他人。这增加了失败成本。分叉使失败极其便宜，因为字面上在分叉中发生的任何事情都不能影响其他不使用该分叉的人。

### 预先协调 {#Up-front-Coordination}

*对预先协调的需求越少越好。*

你可以做敌对分叉。你不能做敌对分支。分支依赖于预先协调，这是昂贵和脆弱的。一个人可以否决整个群体的愿望。例如在ZeroMQ社区中，我们无法就git分支模型达成一年的协议。我们通过使用分叉来解决这个问题。问题消失了。

### 可扩展性 {#Scalability}

*你越能扩展项目越好。*

所有分支策略中的强假设是存储库*就是*项目。但你能让多少人同意在一个存储库中一起工作是有限制的。正如我解释的，预先协调的成本可能变成致命的。更现实的项目通过允许任何人开始他们自己的存储库，并确保这些可以一起工作来扩展。像ZeroMQ这样的项目有几十个存储库。分叉看起来比分支更可扩展。

### 惊喜和期望 {#Surprise-and-Expectations}

*越少惊喜越好。*

人们期望分支，发现分叉不常见，因此令人困惑。这是分支获胜的一个方面。如果你使用分支，单个补丁将有相同的提交哈希标签，而跨分叉补丁将有不同的哈希标签。这确实使跟踪补丁跨分叉更困难。但说真的，*必须跟踪十六进制哈希标签不是一个特性*。这是一个bug。有时更好的工作方式起初是令人惊讶的。

### 参与经济学 {#Economics-of-Participation}

*越有形的奖励越好。*

人们喜欢拥有他们的工作并获得信用。这对分叉比对分支容易得多。分叉以健康的方式创造更多竞争，而分支抑制竞争并强迫人们合作和分享信用。这听起来积极，但在我的经验中，它使人们失去动力。分支不是你可以"拥有"的产品，而分叉可以是。

### 冲突中的稳健性 {#Robustness-in-Conflict}

*模型越能在冲突中幸存越好。*

喜欢与否，人们为自我、地位、信念和世界理论而战。挑战是科学的必要部分。如果你的组织模型依赖于协议，你不会在第一次真正的战斗中幸存。分支不会在真正的争论和战斗中幸存，而分叉可以是敌对的，仍然惠及所有当事方。这确实是自由软件的工作方式。

## 代码生成 {#Code-Generation}

除了git分支暗杀（我们成功了吗？），ZeroMQ项目提供了大规模C代码生成的优秀案例研究。我们使用代码生成来产生语言绑定和编程API。可以阅读我们的[模型驱动方法](http://hintjens.com/blog:35)的经验。

总结是，使用任何好的代码生成器，你可以：

* 定义一次API，生成许多语言绑定。
* 改进绑定的设计和一致性。
* 确保API被完整翻译到每种语言。
* 自动化大量无聊的工作。

另一方面，你的项目变得依赖于你自己的工具，这有一定的开销。对ZeroMQ我们使用[GSL代码生成器](https://github.com/imatix/gsl)。

## 创新设计 {#Designing-for-Innovation}

让我们看看创新，维基百科将其定义为"通过满足新要求、不明确需求或以增值新方式满足旧客户和市场需求的解决方案来开发新价值"。这实际上只是意味着更便宜地解决问题。这听起来很直接，但科技巨头倒闭的历史证明它并不是。我将尝试解释团队如何经常做错，并建议一种正确创新的方法。

### 两座桥的故事 {#The-Tale-of-Two-Bridges}

两个老工程师谈论他们的生活并夸耀他们最伟大的项目。其中一个工程师解释了他如何设计了有史以来最伟大的桥梁之一。

"我们在河谷上建造了它，"他告诉朋友。"它又宽又深。我们花了两年时间研究土地，选择设计和材料。我们雇佣了最好的工程师并设计了桥梁，这又花了五年时间。我们承包最大的工程公司来建造结构、塔楼、收费站和连接桥梁到主要公路的道路。在建设期间有几十人死亡。在道路层下我们有火车，以及骑自行车的人的特殊路径。那座桥代表了我生命中的许多年。"

第二个人思考了一会儿，然后说话。"一天晚上我和朋友喝伏特加喝醉了，我们在峡谷上扔了一根绳子，"他说。"只是一根绳子，绑在两棵树上。有两个村庄，每一边一个。起初，人们用滑轮和绳子在那根绳子上拉包裹。然后有人扔了第二根绳子，建了一个人行道。这很危险，但孩子们喜欢它。一群人然后重建了那个，使它坚固，女人们开始每天过河，带着她们的产品。市场在桥的一边兴起，慢慢地变成了一个大镇，因为有很多房屋空间。绳桥被木桥取代，以允许马匹和手推车过河。然后镇子建了一座真正的石桥，有金属梁。后来，他们用钢替换了石头部分，今天在同一个地方有一座悬索桥。"

第一个人深深地思考。"这很有趣，"他说，"但没有人记得你的名字。我的桥呢？它在工程书籍中。成千上万的学生学习它。"

"不，"第二个人回答，"没有人记得我的名字，这是事实。但你知道什么？整个城市记得我的桥。"

### ZeroMQ如何失去路线图 {#How-ZeroMQ-Lost-Its-Road-Map}

关于软件架构的重要教训是，大设计通常是错误的。大设计来自一小群人的智慧，但好的架构来自黑客和用户社区。如果你想要制作软件架构，你必须开始小规模，给每个人机会参与，继续生长设计，永远不要从头再来。

这给我们留下了一个问题。几乎每个成功的开源项目都是从一个人的个人需求开始的。这个人通常大声宣布（或一群朋友说服），"建造它，人们会来"和BDFL（仁慈的独裁者）抓住控制权。好的BDFL和坏的BDFL之间的区别在于好的人逐渐让社区成长，而坏的人保持控制权。

ZeroMQ项目在2007年由当时在iMatix工作的我和Martin Sustrik启动。我对消息传递模式感兴趣，Martin需要一种处理股票市场数据流的超快方法。Martin写了第一代libzmq，我写了第一个用户指南。我们设计了一个基于AMQP的路线图。

我们的路线图显示了一个在多年来逐步变得AMQP兼容的消息系统。我们得到了来自消息传递专家的正面反馈。"好，"他们说，"最后，一个真正快速的AMQP堆栈！"我们发布了版本0.1，然后0.2，0.3，每个版本都更接近那个AMQP路线图。

消息传递专家没有使用它。但一些其他人开始下载我们的软件。我们注意到人们正在以我们从未想象过的方式使用它。例如，一个用户根本不喜欢消息代理的概念，并问是否有办法使ZeroMQ在没有代理的情况下工作。这令人困惑，整个消息传递的要点不就是要有一个消息代理来存储和转发消息吗？

我们说："好的，让我们试试这个，"我们制作了ZeroMQ的代理工作模式，然后我们制作了一个没有代理的实验性发布。该版本变得非常受欢迎，我们意识到人们根本不想要消息代理。他们想要简单的套接字，但更好、更快、更易于使用。

我们扔掉了路线图，让用户推动设计。令人惊讶的结果是，我们已经积累了数以万计的用户，ZeroMQ已经成为了一个大型生态系统，一个真正的社区，在许多公司和许多应用程序中使用。

我们的经验，一次又一次，反复，以及在许多不同项目中，是用户推动的设计工作，专家设计不工作。如果你要求用户向你解释他们的需求，你将得到无用的答案。但如果你让他们尝试你制作的东西，然后看他们实际做什么，你将学到极有价值的课程。

观察一：起始点无关紧要。最重要的是让来自许多人的快速、准确反馈过程。

观察二：任何真正大、成功的工作都从小开始，增长。一夜之间从小处着手到大处着手的项目，当它们"发布"时，往往以壮观的方式失败。

观察三：不知道你的最终目标是可以的，比坚持错误的目标要好。

现在我想解释为什么我认为制作大型软件架构的计划和自上而下的设计是如此危险，事实上被证明失败。我称之为"建筑师的陷阱"。

这些都是设计陷阱，许多聪明的架构师掉入其中。他们看起来很理性。但是，这些策略会导致过度复杂，这是一个大项目的死亡。

### 垃圾导向设计 {#Trash-Oriented-Design}

第一个陷阱是过度关注特性，我称之为"垃圾导向设计"。这是许多技术失败的主要原因，也是ZeroMQ项目成功的原因之一，我们通过拒绝这种设计方法。

垃圾导向设计有以下模式：

* 该项目由一小群设计师拥有，他们将它拉向某个目标。
* 添加新功能，但几乎从未删除旧功能（"已弃用"但未删除）。
* 旧功能有时会在新的、不兼容的方向上进行更改。
* 用户请求的功能被捆绑到现有的功能中。
* 项目累积功能，但变得越来越难以使用正确。
* 表面上复杂性增长，直到只有专家可以使用项目。

垃圾导向设计的经典案例是近年来的RFC文档，它们极其冗长并且通常相互不兼容，以及二十年来的C++语言（虽然它正在改善）。

许多聪明的架构师认为功能就是价值，更多功能意味着更多价值。实际上，当我们在"简单"和"特性丰富"之间选择时，人们选择简单的。iPhone是古典的例子，当然。

垃圾导向设计对于商业软件制造商来说是诱人的，因为它让他们每年发布新版本。但对于开源项目，特别是那些竞争激烈的项目，这可能是致命的。我看到许多不错的开源项目在添加过多功能时死亡。

如何避免垃圾导向设计：

* 拿每个功能并问："没有这个我们就不能生活吗？"
* 对于每个新功能，找个方法删除现有功能。
* 担心功能的概念重量，而不仅仅是线路数。
* 计算概念，如果计数增长，削减功能。
* 编写文档作为你构建功能。如果你无法简单地解释一个功能，那可能是一个坏功能。

### 复杂性导向设计 {#Complexity-Oriented-Design}

第二个陷阱是，智能设计师往往产生聪明的设计。我称之为"复杂性导向设计"，它至少和垃圾导向设计一样杀手。

这种方法的模式：

* 设计师使用每个可用工具技术，无论是否相关。
* 设计师从类似工作中获得灵感，创建概念框架。
* 设计师辛苦工作，产生多层、多类、多概念的架构。
* 普通程序员无法理解架构。
* 普通程序员犯的错误被归咎于愚蠢，而不是坏设计。

一些不错的软件被复杂性导向设计破坏了。这在"企业"软件中特别常见。我看到许多项目在过多复杂性下死亡。架构师自豪于这种复杂性，并捍卫它。

复杂性导向设计有各种表现形式：

* 无意义、或糟糕命名的概念，组成新的术语。
* 概念的重复层（如"工厂工厂"）。
* 过度使用可配置性和可扩展性。
* 技术驱动的分层，也就是，"应该隔离不同类型的工作"。
* 混合不同类型的用例，以便同一个API被管理员和最终用户调用。

如何避免复杂性导向设计：

* 解决一个具体的问题，仅此而已。
* 问："这个设计的最简单的使用案例是什么？"如果很复杂，问题就在于设计。
* 期望你的用户是不耐心的初学者，你对每个复杂的小时工作，他们将给你三十秒。
* 为了每个概念有名称，要求短的用英语句子来解释它给一个孩子。
* 如果存在现有概念，就重复使用。不要创造概念的变体。
* 当产品太复杂时，分割。不要扩展。

### 简单性导向设计 {#Simplicity-Oriented-Design}

最好的软件具有最少的概念。ZeroMQ的成功是因为，我相信，我们从一开始就关注简单性，尽管在内部实现方面，这并不总是容易做到的。

我们启动ZeroMQ，没有消息队列，没有配置文件，没有服务器进程。只是一个简单的库，给你套接字，但更好。

我们没有试图解决每个消息传递问题，只是最常见的。我们没有试图制作一个框架，只是一个简单的构建工具，通过它你可以创建自己的架构。

这是如何工作的：

1. 我们构建最小的、最简单的东西，可以解决实际用户的具体问题。
2. 我们给它用户，看他们用它做什么，他们抱怨什么。
3. 我们修复最常见的问题，但不是用更多功能。相反，我们重构，以便问题消失。
4. 我们重复此过程，直到没有更多问题需要修复。

简单性导向设计过程通常会产生意外结果。我们已经在ZeroMQ中许多次发现有用性来自意外简化。例如，消除消息代理创造了一个简单但强大的对等网络模式。删除单独配置文件意味着ZeroMQ应用程序可以是"0配置"。

其中：

* 从最小的实用开始。
* 观察用户抱怨的是什么。
* 简化，不要扩展。

## 倦怠 {#Burnout}

我想谈谈成功项目的一个常见问题：倦怠。这特别影响优秀的技术人员，他们往往努力工作，想要修复每个问题，并且对他们生产的质量过度有野心。

倦怠是一个真正的问题。我已经在自己身上看到它以及我工作的人身上。它是我们行业中抑郁症和早期死亡的主要原因。我们往往把倦怠当成个人弱点，一个应该治疗的医学问题。但我不同意。倦怠不是一个人格错误，它是一个设计错误。

避免倦怠的诀窍不是少工作，而是以可持续的方式工作。我这样定义的"可持续工作"：

* 我们可以工作，只要我们想要，因为我们在工作中找到了乐趣和意义。
* 我们不会因工作问题而在个人生活中受苦。
* 我们的工作产出适应我们的精力水平，而不是相反。

对我来说，解决倦怠的关键是这个：**你不拥有你的项目**，你的项目拥有你。我的意思是，项目会变得比任何人都大，如果我们努力控制它们，它们会消耗我们。

我认为，C4流程，我们已经在ZeroMQ项目中使用，是避免倦怠的好方法，因为：

* 没有贡献者对任何事负责，责任总是集体的。
* 没有一个人需要解决每个问题，即使那个人想要。
* 我们通过小的、准确的变化工作，这创造了平稳的进度。
* 我们不会陷入只有少数人才能理解的大型复杂设计。

我一直在可能超过30年的时间里参与开源项目，并且我见过多次倦怠和项目死亡。总是这样，人们试图做太多，太快。它自然地感到压倒性，人们逃离。

如果你运行一个项目，特别是一个成功的项目，你的优先级应该不是增长或质量或任何传统指标。应该是**可持续性**。

## 成功模式 {#Patterns-for-Success}

最后，我想简要介绍成功社会架构师的十种主要人格。这些是我多年来观察到的角色和模式，也是我试图在社区工作中采用的。没有人拥有所有技能。对大多数人来说，最好专注于一个角色，并依靠其他人发挥不同的角色。

### 懒惰的完美主义者 {#The-Lazy-Perfectionist}

*"我选择一个懒惰的人去做困难的工作。因为一个懒惰的人会找到一个容易的方法来做它。"* -- Bill Gates

懒惰的完美主义者知道，最好的代码是你从未写过的代码。她解决问题通过发现这样的事实，即根本没有问题需要解决。如果有数千种方法来做某事，她的工作是发现哪一种涉及的代码、设计和解释最少。懒惰的完美主义者在追求简单性方面无情，因为简单等于完美，她太懒惰，无法获得不完美的东西。

### 仁慈的暴君 {#The-Benevolent-Tyrant}

*"我是邪恶的！我只是一个误导的仁慈暴君。"* -- Linus Torvalds

仁慈的暴君拒绝他不喜欢的补丁，但他只运用这个权力来对代码质量问题，从不为政治原因。他会接受任何正确的补丁，即使来自他不喜欢的人。他永远不会因为不喜欢作者而拒绝正确的补丁，也不会因为喜欢作者而接受破碎的补丁。仁慈的暴君不寻求权力、拥有权力、或从权力中获得任何个人利益。

### 大地与天空 {#The-Earth-and-Sky}

*"在任何人群中有地球人和天空人。"*

地球人是实际的，他们制作真实有效的东西，人们可以用来解决真实的问题。他们关心可用性、测试、文档、部署和操作。天空人是理论的，他们制作美丽的概念、架构、算法和数学。他们关心一致性、可扩展性、可维护性和可复用性。一个好的开源社区需要两种人，如果他们互相尊重而不是战斗，这很有效。

### 开门者 {#The-Open-Door}

*"我为了其他人会有更多的地方了而自愿离开我的位置。"*

开门者具有为其他人而移除她自己的奇怪能力。当项目变得太大以至于她无法监督每个补丁时，她将工作分解为不同的领域，并邀请其他人变为每个领域的维护者。她永远不会囤积责任，或尝试成为不可替代的。开门者接受她的死亡率，将其看作项目健康成长的正常部分。因此，项目变得更大、更有趣和更有趣。她为了工作本身而工作，不为地位或权力。

### 笑着的小丑 {#The-Laughing-Clown}

*"如果你能让人们笑，那么你可以让他们学习。"*

笑着的小丑让学习变得愉快。她从不占据课堂的讲台，而是让每个人都感觉聪明。人们在完美的代码中学到的很少。我们通过制作错误和修复它们来学习，这样我们真正理解问题。笑着的小丑让错误感到愉快，而不是痛苦。她永远不会生气或沮丧，总是能够从她遇到的任何情况中找到好笑的一面。人们很难对那些让他们笑的人生气，所以笑着的小丑通常能够建设性地处理困难的冲突。

## 社会架构师的十种人格 {#Ten-Personalities-of-Social-Architects}

最后，我想简要介绍成功社会架构师的十种主要人格。这些是我多年来观察到的角色和模式，也是我试图在社区工作中采用的。没有人拥有所有技能。对大多数人来说，最好专注于一个角色，并依靠其他人发挥不同的角色。

### 无视的先知 {#The-Ignored-Prophet}

*编写精确预测未来的RFC，然后十年内一直被忽视。*

无视的先知撰写充满智慧的文档，并且总是被证明是正确的。她的问题是人们没有很好地解决想象中的问题。用她的预言之剑，她首先验证她的想法，然后等待现实迫使其他人关注。无视的先知的耐心是无限的，因为时间总是在她这一边。

### 无情的执行者 {#The-Relentless-Executioner}

*总是，没有例外，交付承诺的内容。*

无情的执行者首先做他承诺要做的事情。他有一个超能力，即无论付出什么代价都做他应该做的事情。他是每个项目依赖的人。如果有错误，他就修复它。如果有活动，他就参加。如果有决定要做，他就会到场。他从不生病，从不疲惫，从不有其他事情要做。也许他没有生活，但他使其他人过上充实的生活。

### 正直的策略家 {#The-Honest-Strategist}

*定义目标、develop策略和战术，绝不为权力而说谎。*

正直的策略家看到远景，定义一套目标来到达那里，然后从战略和战术角度传达这些。她的超能力是她从不说谎，即使谎言可能会给她权力。她不为个人利益行动，只为集体利益。因为她诚实和无私，人们会追随她。

### 谦逊的管家 {#The-Humble-Steward}

*负责看不见的工作，确保每个人都有工具和空间，并且正确记录所有内容。*

谦逊的管家做所有你看不到的事情，这让项目实际工作。他安装服务器，配置邮件列表，建立网站，组织聚会，写指南，管理发布。他从不为权力而争取。人们从不感谢他，他也不想要感谢。他知道如果他做得好，很少有人会注意到他做了什么。

### 公正的仲裁者 {#The-Fair-Arbitrator}

*仲裁冲突而不偏袒。*

公正的仲裁者解决那些其他人无法解决的冲突。她只有当其他人要求她时才行动，她的决定受所有人尊重，因为她无法贿赂、欺负或说服违背她的价值观。她不做政治。她从不寻求责任，她只承担迫于她的责任。她从不解释她的决定，因为那会降低她们的权威。

### 敬业的经理 {#The-Mindful-General}

*不制定计划。设定目标，develop策略和战术。*

敬业的经理在未知领域操作，解决隐藏直到它们接近的问题。因此她不制定计划，而是寻找机会，然后快速准确地利用它们。她在现场develop战术和策略，并将这些教给她的士兵，这样他们可以独立移动，一起。

### 社会工程师 {#The-Social-Engineer}

*如果你了解敌人和了解你自己，你不需要担心一百次战斗的结果。* -- 孙子

社会工程师阅读他工作的人和为之工作的人的心灵。他问每个人，"什么使这个人愤怒、不安、争论、平静、快乐？"他研究他们的情绪和性情。有了这种知识，他可以鼓励那些有用的人，阻止那些没用的人。社会工程师从不根据自己的情绪行动。

### 恒定的园丁 {#The-Constant-Gardener}

*全军在所有等级中被相同精神激励的人将获胜。* -- 孙子

恒定的园丁从小种子逐步成长一个流程，随着更多人进入项目。她为每个更改做出精确的理由，得到每个人的同意。她从不从上面强加流程，而是让其他人达成共识，然后她执行那个共识。这样，每个人都一起拥有流程，通过拥有它，他们附着于它。

### 滚石 {#The-Rolling-Stone}

*过河后，你应该远离它。* -- 孙子

滚石接受自己的死亡和无常。他对自己过去的工作没有依恋。他接受我们制作的一切都注定进垃圾桶，这只是时间问题。通过精确、最小的投资，他可以快速远离过去，保持专注于现在和近期未来。最重要的是，他没有自我和骄傲被其他人的行动伤害。

### 海盗团伙 {#The-Pirate-Gang}

*代码，像所有知识一样，作为集体——而不是私人——财产工作得最好。*

海盗团伙围绕问题自由组织。它接受权威，只要权威提供目标和资源。海盗团伙拥有和分享它制作的一切：每个工作都完全可被海盗团伙中的其他人重新混合。团伙随着新问题出现快速移动，如果那些停止相关，快速放弃旧解决方案。没有个人或团体可以垄断供应链的任何部分。

### 快闪族 {#The-Flash-Mob}

*水根据它流过的地面性质塑造其路线。* -- 孙子

快闪族根据需要在空间和时间中聚集，然后一旦他们可以就分散。物理接近对高带宽通信是必需的。但随着时间的推移，它创造技术贫民窟，地球与天空分离。快闪族倾向于收集很多常客里程。

### 金丝雀观察者 {#The-Canary-Watcher}

*痛苦，一般来说，不是一个好迹象。*

金丝雀观察者通过他们自己的痛苦水平和与他工作的人的观察到的痛苦水平来衡量组织的质量。他将新参与者带入现有组织，这样他们可以表达无辜的原始痛苦。他可能使用酒精让其他人说出他们的痛点。他问其他人和自己，"你在这个流程中快乐吗，如果不是，为什么不是？"当组织在他自己或其他人中造成痛苦时，他将其视为要修复的问题。人们应该在工作中感到快乐。

### 刽子手 {#The-Hangman}

*当其他人犯错误时，永远不要打断他们。*

刽子手知道我们只通过犯错误学习，她给其他人大量绳子来学习。她只轻轻拉绳子，当是时候了。轻拉提醒另一个人他们危险的位置。允许其他人通过失败学习给好人留下的理由，给坏人离开的借口。刽子手无尽地耐心，因为学习过程没有捷径。

### 历史学家 {#The-Historian}

*保持公共记录可能很乏味，但这是防止勾结的唯一方法。*

历史学家迫使讨论进入公共视野，以防止勾结拥有工作领域。海盗团伙依赖于不依赖于瞬间存在的完整和平等通信。没有人真正阅读档案，但简单的可能性阻止了大多数滥用。历史学家鼓励适当的工具：电子邮件用于临时讨论，IRC用于闲聊，wiki用于知识，问题跟踪用于记录机会。

### 挑衅者 {#The-Provocateur}

*当一个人知道他将在两周内被绞死时，它奇妙地集中了他的思想。* -- Samuel Johnson

挑衅者创造截止日期、敌人和偶尔的不可能性。团队在没有时间做废话时工作得最好。截止日期将人们聚集在一起并集中集体思想。外部敌人可以将被动团队转为行动。挑衅者从不过于认真对待截止日期。产品*总是*准备发货。但她温和地提醒团队利害关系：失败，我们都寻找其他工作。

### 神秘主义者 {#The-Mystic}

*当人们争论或抱怨时，只要给他们写一个孙子引言* -- Mikko Koppanen

神秘主义者从不直接争论。他知道与情绪化的人争论只会创造更多情绪。相反，他回避讨论。很难对中国将军生气，特别是当他已经死了2,400年。当人们坚持犯错的权利时，神秘主义者扮演刽子手。
