---
weight: 1
title: '1. 基础知识'
---

# 第1章 - 基础知识 {#basics}

## 修复世界 {#Fixing-the-World}

如何解释 ZeroMQ？我们中的一些人开始说它所做的所有美妙的事情。*它是加强版的套接字。它就像带路由的邮箱。它很快！* 其他人试图分享他们的启蒙时刻，那个zap-pow-kaboom的顿悟范式转变时刻，当一切变得显而易见。*事情变得简单。复杂性消失了。它开启了思想。* 其他人试图通过比较来解释。*它更小、更简单，但仍然看起来很熟悉。* 就我个人而言，我喜欢记住我们为什么要制作 ZeroMQ，因为这很可能是你，读者，今天仍然所在的地方。

编程是科学打扮成艺术，因为我们大多数人不理解软件的物理学，而且很少（如果有的话）被教授。软件的物理学不是算法、数据结构、语言和抽象。这些只是我们制造、使用、丢弃的工具。软件的真正物理学是人的物理学——具体来说，我们在复杂性方面的局限性，以及我们希望合作解决大问题的愿望。这是编程的科学：制造人们可以理解和*轻松*使用的构建块，人们将合作解决最大的问题。

我们生活在一个连接的世界中，现代软件必须导航这个世界。因此，明天最大解决方案的构建块是连接的和大规模并行的。代码不再仅仅是"强大而沉默"就足够了。代码必须与代码对话。代码必须是健谈的、社交的、连接良好的。代码必须像人类大脑一样运行，数万亿个个体神经元相互发送消息，一个没有中央控制、没有单点故障的大规模并行网络，但能够解决极其困难的问题。代码的未来看起来像人类大脑并非偶然，因为每个网络的端点在某种程度上都是人类大脑。

如果你曾经做过线程、协议或网络的工作，你会意识到这几乎是不可能的。这是一个梦想。当你开始处理现实生活中的情况时，即使通过几个套接字连接几个程序也是非常棘手的。数万亿？成本将是不可想象的。连接计算机是如此困难，以至于做这件事的软件和服务是一个数十亿美元的业务。

所以我们生活在一个布线领先于我们使用能力数年的世界。我们在1980年代遇到了软件危机，当时像 Fred Brooks 这样的领先软件工程师相信[没有"银弹"](http://en.wikipedia.org/wiki/No_Silver_Bullet)来"承诺在生产力、可靠性或简单性方面甚至一个数量级的改进"。

Brooks 错过了自由和开源软件，它解决了那个危机，使我们能够有效地分享知识。今天我们面临另一个软件危机，但这是一个我们谈论不多的危机。只有最大、最富有的公司才能负担得起创建连接的应用程序。有一个云，但它是专有的。我们的数据和知识正在从我们的个人计算机消失到我们无法访问和无法竞争的云中。谁拥有我们的社交网络？这就像主机-PC革命的逆转。

我们可以把政治哲学[留给另一本书](http://cultureandempire.com)。重点是，虽然互联网提供了大规模连接代码的潜力，但现实是这对我们大多数人来说是遥不可及的，因此大型有趣的问题（在健康、教育、经济、运输等方面）仍然没有解决，因为没有办法连接代码，因此没有办法连接可以合作解决这些问题的大脑。

已经有许多尝试解决连接代码挑战的努力。有数千个IETF规范，每个都解决了拼图的一部分。对于应用程序开发人员来说，HTTP也许是一个足够简单的解决方案，但它可以说通过鼓励开发人员和架构师考虑大服务器和瘦、愚蠢的客户端而使问题变得更糟。

所以今天人们仍然使用原始的UDP和TCP、专有协议、HTTP和Websockets连接应用程序。它仍然是痛苦的、缓慢的、难以扩展的，并且本质上是集中化的。分布式P2P架构主要用于娱乐，而不是工作。有多少应用程序使用Skype或Bittorrent来交换数据？

这使我们回到编程的科学。为了修复世界，我们需要做两件事。第一，解决"如何将任何代码连接到任何代码，任何地方"的一般问题。第二，将其包装在人们可以理解和*轻松*使用的最简单的构建块中。

这听起来荒谬地简单。也许确实如此。这就是整个要点。

## 起始假设 {#Starting-Assumptions}

我们假设你使用的是至少3.2版本的ZeroMQ。我们假设你使用的是Linux机器或类似的东西。我们假设你可以读取C代码，或多或少，因为这是示例的默认语言。我们假设当我们写PUSH或SUBSCRIBE这样的常量时，如果编程语言需要，你可以想象它们实际上被称为<tt>ZMQ_PUSH</tt>或<tt>ZMQ_SUBSCRIBE</tt>。

## 获取示例 {#Getting-the-Examples}

示例存在于一个公共的[GitHub仓库](https://github.com/imatix/zguide)中。获取所有示例的最简单方法是克隆这个仓库：

```
git clone --depth=1 https://github.com/imatix/zguide.git
```

接下来，浏览examples子目录。你会按语言找到示例。如果你使用的语言中缺少示例，我们鼓励你[提交翻译](https://zguide.zeromq.org/translate/)。这就是这个文本变得如此有用的方式，感谢许多人的工作。所有示例都在MIT/X11许可下授权。

## 问，你将会收到 {#Ask-and-Ye-Shall-Receive}

所以让我们从一些代码开始。我们当然从Hello World示例开始。我们将制作一个客户端和一个服务器。客户端向服务器发送"Hello"，服务器回复"World"。这是C中的服务器，它在端口5555上打开一个ZeroMQ套接字，在其上读取请求，并对每个请求回复"World"：

{{< examples name="hwserver" title="Hello World 服务器" >}}

{{< textdiagram name="fig2.png" figno="2" title="请求-回复" >}}
  #------------#
  |   客户端   |
  +------------+
  |    REQ     |
  '---+--------'
      |    ^
      |    |
Hello |    | World
      |    |
      v    |
  .--------+---.
  |    REP     |
  +------------+
  |   服务器   |
  #------------#
{{< /textdiagram >}}

REQ-REP套接字对是同步的。客户端发出<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>然后<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>，在一个循环中（或者如果这是它所需要的全部，则一次）。执行任何其他序列（例如，连续发送两条消息）将导致<tt>send</tt>或<tt>recv</tt>调用返回代码-1。类似地，服务根据需要按顺序发出<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>然后<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>。

ZeroMQ使用C作为其参考语言，这是我们将用于示例的主要语言。如果你在线阅读这个，示例下面的链接会带你到其他编程语言的翻译。让我们比较一下C++中的相同服务器：

{{< example name="hwserver" title="Hello World 服务器" language="C++" >}}

你可以看到ZeroMQ API在C和C++中是相似的。在像PHP或Java这样的语言中，我们可以隐藏更多，代码变得更容易阅读：

{{< example name="hwserver" title="Hello World 服务器" language="PHP" >}}

{{< example name="hwserver" title="Hello World 服务器" language="Java" >}}

其他语言的服务器：

{{< examples name="hwserver" title="Hello World 服务器" >}}

这是客户端代码：

{{< examples name="hwclient" title="Hello World 客户端" >}}

现在这看起来太简单了，不太现实，但ZeroMQ套接字，正如我们已经学到的，有超能力。你可以同时向这个服务器投入数千个客户端，它将继续愉快和快速地工作。为了好玩，尝试启动客户端*然后*启动服务器，看看它如何仍然工作，然后想一秒钟这意味着什么。

让我们简要解释一下这两个程序实际在做什么。它们创建一个ZeroMQ上下文来工作，以及一个套接字。不要担心这些词的含义。你会学会的。服务器将其REP（回复）套接字绑定到端口5555。服务器在循环中等待请求，并每次用回复响应。客户端发送请求并从服务器读取回复。

如果你杀死服务器（Ctrl-C）并重新启动它，客户端不会正确恢复。从崩溃的进程中恢复并不那么容易。制作可靠的请求-回复流程足够复杂，我们直到[第4章 - 可靠的请求-回复模式](chapter4#reliable-request-reply)才会涵盖它。

幕后发生了很多事情，但对我们程序员来说重要的是代码有多短和多甜美，以及它多么经常不崩溃，即使在重负载下。这是请求-回复模式，可能是使用ZeroMQ的最简单方式。它映射到RPC和经典的客户端/服务器模型。

## 关于字符串的小注记 {#A-Minor-Note-on-Strings}

ZeroMQ除了字节大小之外，对你发送的数据一无所知。这意味着你有责任安全地格式化它，以便应用程序可以读回它。对于对象和复杂数据类型，这是专门库（如Protocol Buffers）的工作。但即使对于字符串，你也需要小心。

在C和其他一些语言中，字符串以空字节结尾。我们可以发送一个像"HELLO"这样的字符串，带有额外的空字节：

```C
zmq_send (requester, "Hello", 6, 0);
```

但是，如果你从另一种语言发送字符串，它可能不包括那个空字节。例如，当我们在Python中发送相同的字符串时，我们这样做：

```Python
socket.send ("Hello")
```

然后传输到线路上的是一个长度（对于较短的字符串是一个字节）和字符串内容作为单个字符。

{{< textdiagram name="fig3.png" figno="3" title="ZeroMQ字符串" >}}
#-----#  #-----+-----+-----+-----+-----#
|  5  |  |  H  |  e  |  l  |  l  |  o  |
#-----#  #-----+-----+-----+-----+-----#
{{< /textdiagram >}}

如果你从C程序中读取这个，你会得到看起来像字符串的东西，可能偶然表现得像字符串（如果运气好，这五个字节发现自己后面跟着一个无辜潜伏的空字符），但不是一个合适的字符串。当你的客户端和服务器不同意字符串格式时，你会得到奇怪的结果。

当你在C中从ZeroMQ接收字符串数据时，你根本不能相信它是安全终止的。每次读取字符串时，你应该分配一个新的缓冲区，为额外的字节留出空间，复制字符串，并用空字符正确终止它。

所以让我们建立这样的规则：**ZeroMQ字符串是长度指定的，在传输时*不带*尾随空字符**。在最简单的情况下（我们将在示例中这样做），ZeroMQ字符串整齐地映射到ZeroMQ消息帧，看起来像上图——一个长度和一些字节。

这是我们在C中需要做的，接收ZeroMQ字符串并将其作为有效的C字符串传递给应用程序：

```C
//  从套接字接收ZeroMQ字符串并转换为C字符串
//  如果字符串超过255个字符，则截断
static char *
s_recv (void *socket) {
    char buffer [256];
    int size = zmq_recv (socket, buffer, 255, 0);
    if (size == -1)
        return NULL;
    if (size > 255)
        size = 255;
    buffer [size] = '\0';
    /* 在*nix中使用strndup(buffer, sizeof(buffer)-1) */
    return strdup (buffer);
}
```

这形成了一个方便的辅助函数，本着制作我们可以有利地重用的东西的精神，让我们编写一个类似的<tt>s_send</tt>函数，以正确的ZeroMQ格式发送字符串，并将其打包到我们可以重用的头文件中。

结果是<tt>zhelpers.h</tt>，它让我们在C中编写更甜美和更短的ZeroMQ应用程序。它是一个相当长的源代码，只对C开发人员有趣，所以[随意阅读](https://github.com/imatix/zguide/blob/master/examples/C/zhelpers.h)。

## 关于命名约定的注记 {#A-Note-on-the-Naming-Convention}

在<tt>zhelpers.h</tt>和本指南中后续示例中使用的前缀<tt>s_</tt>是静态方法或变量的指示符。

## 版本报告 {#Version-Reporting}

ZeroMQ确实有几个版本，很多时候，如果你遇到问题，那将是在后来版本中已经修复的东西。所以知道你实际链接的ZeroMQ版本*确切*是什么是一个有用的技巧。

这是一个做这件事的小程序：

{{< examples name="version" title="ZeroMQ版本报告" >}}

## 传播消息 {#Getting-the-Message-Out}

第二个经典模式是单向数据分发，其中服务器向一组客户端推送更新。让我们看一个推送天气更新的示例，包括邮政编码、温度和相对湿度。我们将生成随机值，就像真正的气象站一样。

这是服务器。我们将为此应用程序使用端口5556：

{{< examples name="wuserver" title="天气更新服务器" >}}

这个更新流没有开始也没有结束，就像一个永无止境的广播。

这是客户端应用程序，它监听更新流并抓取与指定邮政编码相关的任何内容，默认为纽约市，因为那是开始任何冒险的好地方：

{{< examples name="wuclient" title="天气更新客户端" >}}

{{< textdiagram name="fig4.png" figno="4" title="发布-订阅" >}}
               #-------------#
               |  发布者     |
               +-------------+
               |     PUB     |
               '-------------'
                    bind
                      |
                      |
                   updates
                      |
      .---------------+---------------.
      |               |               |
   updates         updates         updates
      |               |               |
      |               |               |
      v               v               v
   connect         connect         connect
.------------.  .------------.  .------------.
|    SUB     |  |    SUB     |  |    SUB     |
+------------+  +------------+  +------------+
| 订阅者     |  | 订阅者     |  | 订阅者     |
#------------#  #------------#  #------------#
{{< /textdiagram >}}

注意，当你使用SUB套接字时，你**必须**使用<tt>[zmq_setsockopt()](http://api.zeromq.org/master:zmq_setsockopt)</tt>和SUBSCRIBE设置订阅，如此代码所示。如果你不设置任何订阅，你不会得到任何消息。这是初学者的常见错误。订阅者可以设置许多订阅，这些订阅被添加在一起。也就是说，如果更新匹配任何订阅，订阅者就会收到它。订阅者也可以取消特定的订阅。订阅通常但不总是可打印的字符串。有关其工作原理，请参见<tt>[zmq_setsockopt()](http://api.zeromq.org/master:zmq_setsockopt)</tt>。

PUB-SUB套接字对是异步的。客户端执行<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>，在循环中（或一次，如果这是它所需要的全部）。尝试向SUB套接字发送消息会导致错误。类似地，服务根据需要经常执行<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>，但不能在PUB套接字上执行<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>。

理论上，使用ZeroMQ套接字，哪一端连接哪一端绑定并不重要。但是，在实践中有一些未记录的差异，我稍后会谈到。现在，绑定PUB并连接SUB，除非你的网络设计使这成为不可能。

关于PUB-SUB套接字还有一件重要的事情要知道：你不知道订阅者何时开始接收消息。即使你启动订阅者，等待一会儿，然后启动发布者，**订阅者总是会错过发布者发送的第一条消息**。这是因为当订阅者连接到发布者时（这需要很小但非零的时间），发布者可能已经在发送消息了。

这种"慢连接者"症状经常影响足够多的人，我们将详细解释它。记住ZeroMQ执行异步I/O，即在后台。假设你有两个节点按这个顺序执行：

* 订阅者连接到端点并接收和计数消息。
* 发布者绑定到端点并立即发送1,000条消息。

那么订阅者很可能不会收到任何东西。你会眨眼，检查你设置了正确的过滤器并再试一次，订阅者仍然不会收到任何东西。

建立TCP连接涉及来回握手，根据你的网络和对等点之间的跳数，需要几毫秒。在那段时间里，ZeroMQ可以发送许多消息。为了论证，假设建立连接需要5毫秒，同样的链路可以处理每秒100万条消息。在订阅者连接到发布者的5毫秒期间，发布者只需要1毫秒就能发送出那1K条消息。

在[第2章 - 套接字和模式](chapter2#sockets-and-patterns)中，我们将解释如何同步发布者和订阅者，这样你就不会在订阅者真正连接并准备好之前开始发布数据。有一种简单而愚蠢的方法来延迟发布者，那就是睡眠。不要在真正的应用程序中这样做，因为它极其脆弱，也不优雅和缓慢。使用睡眠来向自己证明正在发生什么，然后等待[第2章 - 套接字和模式](chapter2#sockets-and-patterns)看如何正确地做这件事。

同步的替代方案是简单地假设发布的数据流是无限的，没有开始也没有结束。人们也假设订阅者不关心它启动之前发生了什么。这就是我们构建天气客户端示例的方式。

所以客户端订阅其选择的邮政编码并收集该邮政编码的100次更新。这意味着来自服务器的大约一千万次更新，如果邮政编码是随机分布的。你可以启动客户端，然后启动服务器，客户端将继续工作。你可以随意停止和重新启动服务器，客户端将继续工作。当客户端收集了一百次更新后，它计算平均值，打印它，然后退出。

关于发布-订阅（pub-sub）模式的一些要点：

* 订阅者可以连接到多个发布者，每次使用一个连接调用。然后数据会到达并被交错（"公平排队"），这样没有单个发布者淹没其他发布者。

* 如果发布者没有连接的订阅者，那么它将简单地丢弃所有消息。

* 如果你使用TCP并且订阅者很慢，消息将在发布者上排队。我们稍后会看如何使用"高水位标记"来保护发布者免受这种情况的影响。

* 从ZeroMQ v3.x开始，当使用连接协议（<tt>tcp:@<*>@</tt>或<tt>ipc:@<*>@</tt>）时，过滤发生在发布者端。使用<tt>epgm:@<//>@</tt>协议时，过滤发生在订阅者端。在ZeroMQ v2.x中，所有过滤都发生在订阅者端。

这是在我的笔记本电脑上接收和过滤1000万条消息需要的时间，这是一台2011年代的Intel i5，不错但没什么特别的：

```
$ time wuclient
从天气服务器收集更新...
邮政编码'10001'的平均温度是28F

real    0m4.470s
user    0m0.000s
sys     0m0.008s
```

## 分而治之 {#Divide-and-Conquer}

{{< textdiagram name="fig5.png" figno="5" title="并行管道" >}}
            #-------------#
            |  通风机     |
            +-------------+
            |    PUSH     |
            '------+------'
                   |
                   | tasks
                   |
      .------------+-------------.
      |            |             |
      v            v             v
.----------.  .----------.  .----------.
|   PULL   |  |   PULL   |  |   PULL   |
+----------+  +----------+  +----------+
|  工作者  |  |  工作者  |  |  工作者  |
+----------+  +----------+  +----------+
|   PUSH   |  |   PUSH   |  |   PUSH   |
'----+-----'  '----+-----'  '----+-----'
      |            |             |
      '------------+-------------'
                   |
                   | results
                   |
                   v
            .-------------.
            |    PULL     |
            +-------------+
            |    汇聚     |
            #-------------#
{{< /textdiagram >}}

作为最后一个示例（你肯定已经厌倦了丰富的代码，想要深入讨论关于比较抽象规范的哲学讨论），让我们做一点超级计算。然后咖啡。我们的超级计算应用程序是一个相当典型的并行处理模型。我们有：

* 一个产生可以并行完成的任务的通风机
* 一组处理任务的工作者
* 一个从工作者进程收集结果的汇聚器

在现实中，工作者在超快的机器上运行，可能使用GPU（图形处理单元）来进行繁重的数学运算。这是通风机。它生成100个任务，每个任务都是一条消息，告诉工作者睡眠若干毫秒：

{{< examples name="taskvent" title="并行任务通风机" >}}

这是工作者应用程序。它接收消息，睡眠指定的秒数，然后发出信号表明它已经完成：

{{< examples name="taskwork" title="并行任务工作者" >}}

这是汇聚应用程序。它收集100个任务，然后计算整体处理花费的时间，这样我们可以确认如果有多个工作者，它们确实在并行运行：

{{< examples name="tasksink" title="并行任务汇聚" >}}

一批的平均成本是5秒。当我们启动1、2或4个工作者时，我们从汇聚器得到这样的结果：

* 1个工作者：总耗时：5034毫秒。
* 2个工作者：总耗时：2421毫秒。
* 4个工作者：总耗时：1018毫秒。

让我们更详细地看看这个代码的一些方面：

* 工作者向上游连接到通风机，向下游连接到汇聚器。这意味着你可以任意添加工作者。如果工作者绑定到它们的端点，你将需要（a）更多端点和（b）每次添加工作者时修改通风机和/或汇聚器。我们说通风机和汇聚器是我们架构的*稳定*部分，工作者是*动态*部分。

* 我们必须同步批处理的开始与所有工作者的启动和运行。这是ZeroMQ中相当常见的问题，没有简单的解决方案。<tt>zmq_connect</tt>方法需要一定的时间。所以当一组工作者连接到通风机时，第一个成功连接的工作者将在其他工作者也在连接的短时间内获得大量消息。如果你不以某种方式同步批处理的开始，系统根本不会并行运行。尝试删除通风机中的等待，看看会发生什么。

* 通风机的PUSH套接字将任务分发给工作者（假设它们在批处理开始发出之前都已连接）均匀。这被称为*负载平衡*，我们将再次更详细地研究它。

* 汇聚器的PULL套接字从工作者均匀地收集结果。这被称为*公平排队*。

{{< textdiagram name="fig6.png" figno="6" title="公平排队" >}}
#---------#   #---------#   #---------#
|  PUSH   |   |  PUSH   |   |  PUSH   |
'----+----'   '----+----'   '----+----'
     |             |             |
  R1,| R2, R3      | R4       R5,| R6
     |             |             |
     '-------------+-------------'
                   |
               fair| queuing
        R1, R4, R5,| R2, R6, R3
                   |
                   v
            .-------------.
            |     PULL    |
            #-------------#
{{< /textdiagram >}}

管道模式也表现出"慢连接者"症状，导致指责PUSH套接字不能正确负载平衡。如果你使用PUSH和PULL，你的一个工作者得到的消息比其他工作者多得多，那是因为那个PULL套接字比其他工作者连接得更快，在其他工作者设法连接之前抓取了很多消息。如果你想要适当的负载平衡，你可能想要查看[第3章 - 高级请求-回复模式](chapter3#advanced-request-reply)中的负载平衡模式。

## 使用ZeroMQ编程 {#Programming-with-ZeroMQ}

看了一些示例后，你一定渴望开始在一些应用程序中使用ZeroMQ。在开始之前，深呼吸，放松，并反思一些基本建议，这将为你节省很多压力和困惑。

* 逐步学习ZeroMQ。它只是一个简单的API，但它隐藏了一个可能性的世界。慢慢地接受可能性并掌握每一个。

* 编写优雅的代码。丑陋的代码隐藏问题并使其他人难以帮助你。你可能习惯了毫无意义的变量名，但阅读你代码的人不会。使用真实的单词，说出除了"我太粗心了，不能告诉你这个变量真正用于什么"之外的其他东西。使用一致的缩进和清洁的布局。编写优雅的代码，你的世界将更加舒适。

* 在制作过程中测试你制作的东西。当你的程序不工作时，你应该知道哪五行是罪魁祸首。这在你做ZeroMQ魔法时尤其正确，它在你尝试的前几次就是*不会*工作。

* 当你发现事情不按预期工作时，将你的代码分解成片段，测试每一个，看看哪一个不工作。ZeroMQ让你制作本质上模块化的代码；利用这个优势。

* 根据需要制作抽象（类、方法等）。如果你复制/粘贴很多代码，你也会复制/粘贴错误。

### 正确设置上下文 {#Getting-the-Context-Right}

ZeroMQ应用程序总是从创建*上下文*开始，然后使用它来创建套接字。在C中，这是<tt>[zmq_ctx_new()](http://api.zeromq.org/master:zmq_ctx_new)</tt>调用。你应该在进程中创建并使用确切的一个上下文。从技术上讲，上下文是单个进程中所有套接字的容器，并充当<tt>inproc</tt>套接字的传输，这是连接一个进程中线程的最快方式。如果在运行时一个进程有两个上下文，这些就像单独的ZeroMQ实例。如果这明确是你想要的，OK，但否则记住：

**在进程开始时调用一次<tt>[zmq_ctx_new()](http://api.zeromq.org/master:zmq_ctx_new)</tt>，在结束时调用一次<tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt>。**

如果你使用<tt>fork()</tt>系统调用，在fork后和子进程代码开始时执行<tt>[zmq_ctx_new()](http://api.zeromq.org/master:zmq_ctx_new)</tt>。通常，你想要在子进程中做有趣的（ZeroMQ）事情，在父进程中做无聊的进程管理。

### 干净退出 {#Making-a-Clean-Exit}

优雅的程序员与优雅的杀手分享相同的座右铭：完成工作时总是清理。当你在像Python这样的语言中使用ZeroMQ时，东西会自动为你释放。但当使用C时，你必须仔细释放完成的对象，否则你会得到内存泄漏、不稳定的应用程序和一般的不良业报。

内存泄漏是一回事，但ZeroMQ对你如何退出应用程序非常挑剔。原因是技术性和痛苦的，但结果是如果你留下任何套接字打开，<tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt>函数将永远挂起。即使你关闭所有套接字，除非你在关闭套接字之前将LINGER设置为零，否则如果有挂起的连接或发送，<tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt>默认会永远等待。

我们需要担心的ZeroMQ对象是消息、套接字和上下文。幸运的是，至少在简单程序中，这是相当简单的：

* 当你可以时使用<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>和<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>，因为它避免了处理zmq_msg_t对象的需要。

* 如果你确实使用<tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt>，一旦你完成接收的消息，总是通过调用<tt>[zmq_msg_close()](http://api.zeromq.org/master:zmq_msg_close)</tt>立即释放它。

* 如果你打开和关闭很多套接字，那可能是你需要重新设计应用程序的标志。在某些情况下，套接字句柄在你销毁上下文之前不会被释放。

* 当你退出程序时，关闭你的套接字然后调用<tt>[zmq_ctx_destroy()](http://api.zeromq.org/master:zmq_ctx_destroy)</tt>。这会销毁上下文。

这至少是C开发的情况。在具有自动对象销毁的语言中，套接字和上下文将在你离开作用域时被销毁。如果你使用异常，你将必须在类似"final"块的东西中进行清理，就像任何资源一样。

如果你正在做多线程工作，它变得比这更复杂。我们将在下一章中涉及多线程，但因为你们中的一些人，尽管有警告，将尝试在能够安全行走之前跑步，下面是在*多线程*ZeroMQ应用程序中干净退出的快速而肮脏的指南。

首先，不要尝试从多个线程使用相同的套接字。请不要解释为什么你认为这会是极好的乐趣，只是请不要这样做。接下来，你需要关闭每个有正在进行的请求的套接字。正确的方法是设置一个低LINGER值（1秒），然后关闭套接字。如果你的语言绑定在你销毁上下文时不会自动为你做这件事，我建议发送一个补丁。

最后，销毁上下文。这将导致附加线程（即共享相同上下文的线程）中的任何阻塞接收或轮询或发送返回错误。捕获那个错误，然后在*那个*线程中设置linger，关闭套接字，并退出。不要两次销毁相同的上下文。主线程中的<tt>zmq_ctx_destroy</tt>将阻塞，直到它知道的所有套接字都安全关闭。

瞧！它足够复杂和痛苦，任何值得其盐的语言绑定作者都会自动执行此操作，并使套接字关闭舞蹈变得不必要。

## 为什么我们需要ZeroMQ {#Why-We-Needed-ZeroMQ}

既然你已经看到了ZeroMQ的实际应用，让我们回到"为什么"。

现在许多应用程序由跨某种网络（LAN或互联网）的组件组成。因此，许多应用程序开发人员最终会做某种消息传递。一些开发人员使用消息队列产品，但大多数时候他们使用TCP或UDP自己做。这些协议不难使用，但在从A到B发送几个字节和以任何可靠的方式进行消息传递之间有很大的区别。

让我们看看当我们开始使用原始TCP连接片段时面临的典型问题。任何可重用的消息传递层都需要解决所有或大部分这些问题：

* 我们如何处理I/O？我们的应用程序是阻塞的，还是我们在后台处理I/O？这是一个关键的设计决策。阻塞I/O创建的架构不能很好地扩展。但后台I/O可能很难正确做到。

* 我们如何处理动态组件，即暂时消失的片段？我们是否正式将组件分为"客户端"和"服务器"并规定服务器不能消失？如果我们想要将服务器连接到服务器怎么办？我们是否尝试每隔几秒重新连接？

* 我们如何在线路上表示消息？我们如何构建数据，使其易于编写和读取，防止缓冲区溢出，对小消息高效，但对最大的跳舞猫戴派对帽的视频足够？

* 我们如何处理无法立即传递的消息？特别是，如果我们等待组件重新上线？我们是否丢弃消息，将它们放入数据库，或放入内存队列？

* 我们在哪里存储消息队列？如果从队列读取的组件非常慢并导致我们的队列建立起来，会发生什么？那时我们的策略是什么？

* 我们如何处理丢失的消息？我们是否等待新数据，请求重新发送，还是构建某种可靠性层来确保消息不会丢失？如果那个层本身崩溃怎么办？

* 如果我们需要使用不同的网络传输怎么办。比如说，多播而不是TCP单播？或者IPv6？我们是否需要重写应用程序，还是传输在某个层中抽象了？

* 我们如何路由消息？我们能否将同一消息发送给多个对等点？我们能否将回复发送回原始请求者？

* 我们如何为另一种语言编写API？我们是否重新实现线级协议还是重新打包库？如果是前者，我们如何保证高效和稳定的堆栈？如果是后者，我们如何保证互操作性？

* 我们如何表示数据，以便它可以在不同架构之间读取？我们是否强制数据类型的特定编码？这在多大程度上是消息系统而不是更高层的工作？

* 我们如何处理网络错误？我们是否等待并重试，静默忽略它们，还是中止？

以一个典型的开源项目如[Hadoop Zookeeper](https://zookeeper.apache.org/)为例，阅读<tt>[src/c/src/zookeeper.c](http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c)</tt>中的C API代码。当我在2013年1月阅读这个代码时，它是4,200行神秘代码，其中有一个未记录的客户端/服务器网络通信协议。我看到它是高效的，因为它使用<tt>poll</tt>而不是<tt>select</tt>。但真的，Zookeeper应该使用通用消息层和明确记录的线级协议。团队一遍又一遍地构建这个特定的轮子是极其浪费的。

但如何制作可重用的消息系统？为什么，当这么多项目需要这种技术时，人们仍然在代码中驱动TCP套接字并一遍又一遍地解决那个长列表中的问题，这样做很困难？

事实证明，构建可重用的消息系统真的很困难，这就是为什么很少有FOSS项目尝试过，为什么商业消息产品复杂、昂贵、不灵活和脆弱。2006年，iMatix设计了[AMQP](http://www.amqp.org)，它开始给FOSS开发人员也许是第一个可重用的消息系统配方。AMQP工作得比许多其他设计更好，[但仍然相对复杂、昂贵和脆弱](https://web.archive.org/web/20190620095529/www.imatix.com/articles:whats-wrong-with-amqp)。学习使用需要几周时间，创建当事情变得棘手时不会崩溃的稳定架构需要几个月时间。

{{< textdiagram name="fig7.png" figno="7" title="消息传递的开始" >}}
.------------.
|            |
|  片段 A    |
|            |
'------------'
      ^
      |
      | TCP
      |
      v
.------------.
|            |
|  片段 B    |
|            |
'------------'
{{< /textdiagram >}}

大多数试图以可重用方式解决这个长问题列表的消息项目，如AMQP，都是通过发明一个新概念"代理"来实现的，该代理进行寻址、路由和排队。这导致了客户端/服务器协议或一组API，位于一些未记录的协议之上，允许应用程序与此代理对话。代理在减少大型网络复杂性方面是优秀的东西。但向像Zookeeper这样的产品添加基于代理的消息传递会使其变得更糟，而不是更好。这意味着添加一个额外的大盒子和一个新的单点故障。代理迅速成为瓶颈和需要管理的新风险。如果软件支持，我们可以添加第二个、第三个和第四个代理并制作一些故障转移方案。人们这样做。它创建了更多移动的片段、更多的复杂性和更多要破坏的东西。

以代理为中心的设置需要自己的运营团队。你真的需要日夜监视代理，当它们开始行为不当时用棍子打它们。你需要机器，你需要备份机器，你需要人来管理那些机器。只有对于由几个团队的人在几年内构建的具有许多移动片段的大型应用程序，这才值得做。

{{< textdiagram name="fig8.png" figno="8" title="消息传递的演变" >}}
        .---.             .---.
.---.   |   |   .---.  ^  |   |
|   +-->|   |<--|   |  |  |   |
|   |   '---'   |   |  |  '-+-'
'-+-'           '-+-'  |    |
  |               ^    |    |
  |       .-------+----+----'
  |       |       |    |
  '-------+-------+----+--.
          |       |    |  |
  .-------+-------+----+--+-----.
  |       v       |       v     |
.-+-.   .---.     |     .---.   |
|   |   |   |   .-+-.   |   |-->|
|   +-->|   +-->|   +-->|   |   |
'---'   '---'   |   |   '---'   |
          ^     '-+-'     ^     |
          |       |       |     |
  .-------+-------+-------'     |
  |       |       |             |
  v     .-+-.     v     .---.   |
.---.   |   |   .---.   |   |   |
|   |<--|   |<--|   |<--|   |<--'
|   |   '---'   |   |   '---'
'---'           '---'
{{< /textdiagram >}}

所以中小型应用程序开发人员被困住了。要么他们避免网络编程并制作不能很好扩展的单体应用程序。要么他们跳入网络编程并制作脆弱、复杂的应用程序，难以维护。要么他们押注消息产品，最终得到依赖昂贵、容易破坏技术的可扩展应用程序。没有真正好的选择，这也许是为什么消息传递在很大程度上停留在上个世纪并引起强烈情绪：用户的负面情绪，那些销售支持和许可证的人的快乐。

我们需要的是做消息传递工作的东西，但以如此简单和便宜的方式做，它可以在任何应用程序中工作，几乎零成本。它应该是一个你只需链接的库，没有任何其他依赖项。没有额外的移动片段，所以没有额外的风险。它应该在任何操作系统上运行并与任何编程语言一起工作。

这就是ZeroMQ：一个高效的、可嵌入的库，解决应用程序需要在网络上变得很好弹性的大部分问题，没有太多成本。

具体来说：

* 它在后台线程中异步处理I/O。这些使用无锁数据结构与应用程序线程通信，因此并发ZeroMQ应用程序不需要锁、信号量或其他等待状态。

* 组件可以动态来去，ZeroMQ将自动重新连接。这意味着你可以以任何顺序启动组件。你可以创建"面向服务的架构"（SOA），其中服务可以随时加入和离开网络。

* 它在需要时自动排队消息。它智能地做这件事，在排队之前将消息推送到尽可能接近接收者的地方。

* 它有处理过满队列的方法（称为"高水位标记"）。当队列满时，ZeroMQ自动阻塞发送者或丢弃消息，取决于你正在做的消息传递类型（所谓的"模式"）。

* 它让你的应用程序通过任意传输进行对话：TCP、多播、进程内、进程间。你不需要更改代码来使用不同的传输。

* 它使用不同的策略安全地处理慢/阻塞的读者，这些策略取决于消息传递模式。

* 它让你使用各种模式路由消息，如请求-回复和发布-订阅。这些模式是你创建拓扑、网络结构的方式。

* 它让你用一个调用创建代理来排队、转发或捕获消息。代理可以减少网络的互连复杂性。

* 它使用线路上的简单帧传递完整的消息，完全按照发送的方式。如果你写一个10k消息，你将收到一个10k消息。

* 它不对消息强加任何格式。它们是从零到千兆字节大的块。当你想要表示数据时，你选择其他产品，如msgpack、Google的protocol buffers和其他。

* 它通过在有意义的情况下自动重试来智能地处理网络错误。

* 它减少你的碳足迹。用更少的CPU做更多意味着你的机器使用更少的电力，你可以让你的旧机器使用更长时间。阿尔·戈尔会喜欢ZeroMQ。

实际上ZeroMQ做得更多。它对你如何开发网络能力应用程序有颠覆性影响。表面上，它是一个受套接字启发的API，你在其上执行<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>和<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>。但消息处理迅速成为中央循环，你的应用程序很快分解为一组消息处理任务。它是优雅和自然的。它可以扩展：每个这些任务映射到一个节点，节点通过任意传输相互对话。一个进程中的两个节点（节点是线程），一个机器上的两个节点（节点是进程），或一个网络上的两个节点（节点是机器）——这都是一样的，没有应用程序代码更改。

## 套接字可扩展性 {#Socket-Scalability}

让我们看看ZeroMQ的可扩展性在实际中的表现。这是一个shell脚本，启动天气服务器然后并行启动一堆客户端：

```
wuserver &
wuclient 12345 &
wuclient 23456 &
wuclient 34567 &
wuclient 45678 &
wuclient 56789 &
```

当客户端运行时，我们使用<tt>top</tt>命令查看活动进程，我们看到这样的东西（在4核机器上）：

```
PID  USER  PR  NI  VIRT  RES  SHR S %CPU %MEM   TIME+  COMMAND
7136  ph   20   0 1040m 959m 1156 R  157 12.0 16:25.47 wuserver
7966  ph   20   0 98608 1804 1372 S   33  0.0  0:03.94 wuclient
7963  ph   20   0 33116 1748 1372 S   14  0.0  0:00.76 wuclient
7965  ph   20   0 33116 1784 1372 S    6  0.0  0:00.47 wuclient
7964  ph   20   0 33116 1788 1372 S    5  0.0  0:00.25 wuclient
7967  ph   20   0 33072 1740 1372 S    5  0.0  0:00.35 wuclient
```

让我们想一秒钟这里发生了什么。天气服务器有一个套接字，但这里我们让它并行向五个客户端发送数据。我们可以有数千个并发客户端。服务器应用程序看不到它们，不直接与它们对话。所以ZeroMQ套接字像一个小服务器一样工作，静默接受客户端请求并以网络能够处理的速度向它们推送数据。它是一个多线程服务器，从你的CPU中榨取更多汁液。

## 从ZeroMQ v2.2升级到ZeroMQ v3.2 {#Upgrading-from-ZeroMQ-v-to-ZeroMQ-v}

### 兼容性变化 {#Compatible-Changes}

这些变化不直接影响现有的应用程序代码：

* 发布-订阅过滤现在在发布者端而不是订阅者端进行。这在许多发布-订阅用例中显著提高了性能。你可以安全地混合v3.2和v2.1/v2.2发布者和订阅者。

* ZeroMQ v3.2有许多新的API方法（<tt>[zmq_disconnect()](http://api.zeromq.org/master:zmq_disconnect)</tt>、<tt>[zmq_unbind()](http://api.zeromq.org/master:zmq_unbind)</tt>、<tt>[zmq_monitor()](http://api.zeromq.org/master:zmq_monitor)</tt>、<tt>[zmq_ctx_set()](http://api.zeromq.org/master:zmq_ctx_set)</tt>等）

### 不兼容性变化 {#Incompatible-Changes}

这些是对应用程序和语言绑定的主要影响领域：

* 更改的send/recv方法：<tt>[zmq_send()](http://api.zeromq.org/master:zmq_send)</tt>和<tt>[zmq_recv()](http://api.zeromq.org/master:zmq_recv)</tt>有不同的、更简单的接口，旧功能现在由<tt>[zmq_msg_send()](http://api.zeromq.org/master:zmq_msg_send)</tt>和<tt>[zmq_msg_recv()](http://api.zeromq.org/master:zmq_msg_recv)</tt>提供。症状：编译错误。解决方案：修复你的代码。

* 这两个方法在成功时返回正值，在错误时返回-1。在v2.x中，它们在成功时总是返回零。症状：当事情实际工作正常时出现明显错误。解决方案：严格测试返回代码= -1，而不是非零。

* <tt>[zmq_poll()](http://api.zeromq.org/master:zmq_poll)</tt>现在等待毫秒，而不是微秒。症状：应用程序停止响应（实际上响应慢1000倍）。解决方案：在所有<tt>zmq_poll</tt>调用中使用下面定义的<tt>ZMQ_POLL_MSEC</tt>宏。

* <tt>ZMQ_NOBLOCK</tt>现在称为<tt>ZMQ_DONTWAIT</tt>。症状：<tt>ZMQ_NOBLOCK</tt>宏的编译失败。

* <tt>ZMQ_HWM</tt>套接字选项现在分解为<tt>ZMQ_SNDHWM</tt>和<tt>ZMQ_RCVHWM</tt>。症状：<tt>ZMQ_HWM</tt>宏的编译失败。

* 大多数但不是所有<tt>[zmq_getsockopt()](http://api.zeromq.org/master:zmq_getsockopt)</tt>选项现在是整数值。症状：<tt>zmq_setsockopt</tt>和<tt>zmq_getsockopt</tt>的运行时错误返回。

* <tt>ZMQ_SWAP</tt>选项已被删除。症状：<tt>ZMQ_SWAP</tt>的编译失败。解决方案：重新设计使用此功能的任何代码。

### 建议的垫片宏 {#Suggested-Shim-Macros}

对于想要在v2.x和v3.2上运行的应用程序，如语言绑定，我们的建议是尽可能模拟v3.2。这里是帮助你的C/C++代码在两个版本上工作的C宏定义（取自[CZMQ](http://czmq.zeromq.org)）：

{{< fragment name="upgrade-shim" >}}
#ifndef ZMQ_DONTWAIT
#   define ZMQ_DONTWAIT     ZMQ_NOBLOCK
#endif
#if ZMQ_VERSION_MAJOR == 2
#   define zmq_msg_send(msg,sock,opt) zmq_send (sock, msg, opt)
#   define zmq_msg_recv(msg,sock,opt) zmq_recv (sock, msg, opt)
#   define zmq_ctx_destroy(context) zmq_term(context)
#   define ZMQ_POLL_MSEC    1000        //  zmq_poll is usec
#   define ZMQ_SNDHWM ZMQ_HWM
#   define ZMQ_RCVHWM ZMQ_HWM
#elif ZMQ_VERSION_MAJOR == 3
#   define ZMQ_POLL_MSEC    1           //  zmq_poll is msec
#endif
{{< /fragment >}}

## 警告：不稳定的范式！ {#Warning-Unstable-Paradigms}

传统的网络编程建立在"一个套接字对话一个连接、一个对等点"的一般假设之上。有多播协议，但这些是异乎寻常的。当我们假设"一个套接字=一个连接"时，我们以某种方式扩展我们的架构。我们创建逻辑线程，其中每个线程使用一个套接字、一个对等点。我们将智能和状态放在这些线程中。

在ZeroMQ宇宙中，套接字是快速小后台通信引擎的门户，这些引擎为你自动管理整套连接。你看不到、处理不了、打开不了、关闭不了或将状态附加到这些连接上。无论你使用阻塞发送或接收，还是轮询，你能对话的只是套接字，而不是它为你管理的连接。连接是私有和不可见的，这是ZeroMQ可扩展性的关键。

这是因为你的代码，与套接字对话，然后可以处理任何数量的跨任何网络协议的连接，无需更改。坐在ZeroMQ中的消息模式比坐在你的应用程序代码中的消息模式扩展得更便宜。

所以一般假设不再适用。当你阅读代码示例时，你的大脑会试图将它们映射到你所知道的。你会读到"套接字"并想"啊，那代表与另一个节点的连接"。那是错误的。你会读到"线程"，你的大脑会再次想，"啊，一个线程代表与另一个节点的连接"，你的大脑又会是错误的。

如果你第一次阅读这个指南，意识到直到你实际编写ZeroMQ代码一两天（也许三四天），你可能会感到困惑，特别是ZeroMQ为你简化事情的方式，你可能会试图将那个一般假设强加给ZeroMQ，它不会工作。然后你会体验你的启蒙和信任时刻，那个*zap-pow-kaboom*的顿悟范式转变时刻，当一切变得清晰。
