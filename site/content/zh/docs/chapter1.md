---
weight: 1
title: '1. 基础知识'
---

# 第1章 - 基础知识 {#basics}

## 修复世界 {#Fixing-the-World}

如何解释 ZeroMQ？我们中的一些人开始说它所做的所有美妙的事情。*它是加强版的套接字。它就像带路由的邮箱。它很快！* 其他人试图分享他们的启蒙时刻，那个zap-pow-kaboom的顿悟范式转变时刻，当一切变得显而易见。*事情变得简单。复杂性消失了。它开启了思想。* 其他人试图通过比较来解释。*它更小、更简单，但仍然看起来很熟悉。* 就我个人而言，我喜欢记住我们为什么要制作 ZeroMQ，因为这很可能是你，读者，今天仍然所在的地方。

编程是科学打扮成艺术，因为我们大多数人不理解软件的物理学，而且很少（如果有的话）被教授。软件的物理学不是算法、数据结构、语言和抽象。这些只是我们制造、使用、丢弃的工具。软件的真正物理学是人的物理学——具体来说，我们在复杂性方面的局限性，以及我们希望合作解决大问题的愿望。这是编程的科学：制造人们可以理解和*轻松*使用的构建块，人们将合作解决最大的问题。

我们生活在一个连接的世界中，现代软件必须导航这个世界。因此，明天最大解决方案的构建块是连接的和大规模并行的。代码不再仅仅是"强大而沉默"就足够了。代码必须与代码对话。代码必须是健谈的、社交的、连接良好的。代码必须像人类大脑一样运行，数万亿个个体神经元相互发送消息，一个没有中央控制、没有单点故障的大规模并行网络，但能够解决极其困难的问题。代码的未来看起来像人类大脑并非偶然，因为每个网络的端点在某种程度上都是人类大脑。

如果你曾经做过线程、协议或网络的工作，你会意识到这几乎是不可能的。这是一个梦想。当你开始处理现实生活中的情况时，即使通过几个套接字连接几个程序也是非常棘手的。数万亿？成本将是不可想象的。连接计算机是如此困难，以至于做这件事的软件和服务是一个数十亿美元的业务。

所以我们生活在一个布线领先于我们使用能力数年的世界。我们在1980年代遇到了软件危机，当时像 Fred Brooks 这样的领先软件工程师相信[没有"银弹"](http://en.wikipedia.org/wiki/No_Silver_Bullet)来"承诺在生产力、可靠性或简单性方面甚至一个数量级的改进"。

Brooks 错过了自由和开源软件，它解决了那个危机，使我们能够有效地分享知识。今天我们面临另一个软件危机，但这是一个我们谈论不多的危机。只有最大、最富有的公司才能负担得起创建连接的应用程序。有一个云，但它是专有的。我们的数据和知识正在从我们的个人计算机消失到我们无法访问和无法竞争的云中。谁拥有我们的社交网络？这就像主机-PC革命的逆转。

我们可以把政治哲学[留给另一本书](http://cultureandempire.com)。重点是，虽然互联网提供了大规模连接代码的潜力，但现实是这对我们大多数人来说是遥不可及的，因此大型有趣的问题（在健康、教育、经济、运输等方面）仍然没有解决，因为没有办法连接代码，因此没有办法连接可以合作解决这些问题的大脑。

已经有许多尝试解决连接代码挑战的努力。有数千个IETF规范，每个都解决了拼图的一部分。对于应用程序开发人员来说，HTTP也许是一个足够简单的解决方案，但它可以说通过鼓励开发人员和架构师考虑大服务器和瘦、愚蠢的客户端而使问题变得更糟。

所以今天人们仍然使用原始的UDP和TCP、专有协议、HTTP和Websockets连接应用程序。它仍然是痛苦的、缓慢的、难以扩展的，并且本质上是集中化的。分布式P2P架构主要用于娱乐，而不是工作。有多少应用程序使用Skype或Bittorrent来交换数据？

这使我们回到编程的科学。为了修复世界，我们需要做两件事。第一，解决"如何将任何代码连接到任何代码，任何地方"的一般问题。第二，将其包装在人们可以理解和*轻松*使用的最简单的构建块中。

这听起来荒谬地简单。也许确实如此。这就是整个要点。

## 起始假设 {#Starting-Assumptions}

我们假设你使用的是至少3.2版本的ZeroMQ。我们假设你使用的是Linux机器或类似的东西。我们假设你可以读取C代码，或多或少，因为这是示例的默认语言。我们假设当我们写PUSH或SUBSCRIBE这样的常量时，如果编程语言需要，你可以想象它们实际上被称为`ZMQ_PUSH`或`ZMQ_SUBSCRIBE`。

## 获取示例 {#Getting-the-Examples}

示例存在于一个公共的[GitHub仓库](https://github.com/imatix/zguide)中。获取所有示例的最简单方法是克隆这个仓库：

```
git clone --depth=1 https://github.com/imatix/zguide.git
```

接下来，浏览examples子目录。你会按语言找到示例。如果你使用的语言中缺少示例，我们鼓励你[提交翻译](http://zguide.zeromq.org/main:translate)。这就是这个文本变得如此有用的方式，感谢许多人的工作。所有示例都在MIT/X11许可下授权。

## 问，你将会收到 {#Ask-and-Ye-Shall-Receive}

所以让我们从一些代码开始。我们当然从Hello World示例开始。我们将制作一个客户端和一个服务器。客户端向服务器发送"Hello"，服务器回复"World"。这是C中的服务器，它在端口5555上打开一个ZeroMQ套接字，在其上读取请求，并对每个请求回复"World"：

REQ-REP套接字对是同步的。客户端发出`zmq_send()`然后`zmq_recv()`，在一个循环中（或者如果这是它所需要的全部，则一次）。执行任何其他序列（例如，连续发送两条消息）将导致`send`或`recv`调用返回代码-1。类似地，服务根据需要按顺序发出`zmq_recv()`然后`zmq_send()`。

ZeroMQ使用C作为其参考语言，这是我们将用于示例的主要语言。如果你在线阅读这个，示例下面的链接会带你到其他编程语言的翻译。

现在这看起来太简单了，不太现实，但ZeroMQ套接字，正如我们已经学到的，有超能力。你可以同时向这个服务器投入数千个客户端，它将继续愉快和快速地工作。为了好玩，尝试启动客户端*然后*启动服务器，看看它如何仍然工作，然后想一秒钟这意味着什么。

让我们简要解释一下这两个程序实际在做什么。它们创建一个ZeroMQ上下文来工作，以及一个套接字。不要担心这些词的含义。你会学会的。服务器将其REP（回复）套接字绑定到端口5555。服务器在循环中等待请求，并每次用回复响应。客户端发送请求并从服务器读取回复。

如果你杀死服务器（Ctrl-C）并重新启动它，客户端不会正确恢复。从崩溃的进程中恢复并不那么容易。制作可靠的请求-回复流程足够复杂，我们直到后面章节才会涵盖它。

幕后发生了很多事情，但对我们程序员来说重要的是代码有多短和多甜美，以及它多么经常不崩溃，即使在重负载下。这是请求-回复模式，可能是使用ZeroMQ的最简单方式。它映射到RPC和经典的客户端/服务器模型。
