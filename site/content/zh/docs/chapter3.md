---
weight: 3
title: '3. 高级请求-回复模式'
---

# 第3章 - 高级请求-回复模式 {#advanced-request-reply}

在第一章中，我们通过开发一系列小应用程序学习了使用 ZeroMQ 的基础知识，每次都探索 ZeroMQ 的新方面。我们将在本章中继续这种方法，探索构建在 ZeroMQ 核心请求-回复模式之上的高级模式。

我们将涵盖：

* 请求-回复机制如何工作
* 如何组合 REQ、REP、DEALER 和 ROUTER 套接字
* ROUTER 套接字如何详细工作
* 负载均衡模式
* 构建简单的负载均衡消息代理
* 为 ZeroMQ 设计高级 API
* 构建异步请求-回复服务器
* 详细的代理间路由示例

## 负载均衡模式 {#The-Load-Balancing-Pattern}

现在让我们看一些代码。我们将看到如何将 ROUTER 套接字连接到 REQ 套接字，然后连接到 DEALER 套接字。这两个示例遵循相同的逻辑，即*负载均衡*模式。这种模式是我们第一次接触使用 ROUTER 套接字进行故意路由，而不是简单地充当回复通道。

负载均衡模式非常常见，我们将在本书中多次看到它。它解决了简单轮询路由（如 PUSH 和 DEALER 提供的）的主要问题，如果任务不是都大致花费相同的时间，轮询会变得低效。

这是邮局的类比。如果你每个柜台有一个队列，你有一些人买邮票（快速、简单的交易），一些人开新账户（非常慢的交易），那么你会发现买邮票的人不公平地被困在队列中。就像在邮局一样，如果你的消息架构不公平，人们会感到恼火。

邮局的解决方案是创建一个队列，这样即使一个或两个柜台被慢工作困住，其他柜台将继续为客户提供先到先服务的服务。

PUSH 和 DEALER 使用简单方法的一个原因是纯粹的性能。如果你到达任何美国主要机场，你会发现在移民局有长长的人群队列。边境巡逻官员会提前派人在每个柜台排队，而不是使用单一队列。让人们提前走五十码可以为每位乘客节省一两分钟。而且因为每次护照检查大致花费相同的时间，所以多少是公平的。这是 PUSH 和 DEALER 的策略：提前发送工作负载，以减少传输距离。

这是 ZeroMQ 的一个反复出现的主题：世界的问题是多样的，你可以从以正确的方式解决不同的问题中受益。机场不是邮局，一种尺寸实际上不适合任何人。

让我们回到工作者（DEALER 或 REQ）连接到代理（ROUTER）的场景。代理必须知道工作者何时准备就绪，并保持工作者列表，以便它可以每次采用*最近最少使用*的工作者。

解决方案实际上非常简单：工作者在启动时发送"准备就绪"消息，并在完成每项任务后发送。代理逐一读取这些消息。每次读取消息时，它来自最后使用的工作者。因为我们使用 ROUTER 套接字，我们得到一个身份，然后可以用来将任务发送回工作者。

这是对请求-回复的扭曲，因为任务与回复一起发送，任务的任何响应都作为新请求发送。以下代码示例应该使其更清楚。

## 负载均衡消息代理 {#A-Load-Balancing-Message-Broker}

前面的示例是半完整的。它可以使用虚拟请求和回复管理一组工作者，但它没有办法与客户端交谈。如果我们添加第二个*前端* ROUTER 套接字来接受客户端请求，并将我们的示例转换为可以在前端和后端之间切换消息的代理，我们就得到了一个有用且可重用的小型负载均衡消息代理。

这个代理执行以下操作：

* 接受来自一组客户端的连接。
* 接受来自一组工作者的连接。
* 接收来自客户端的请求，并将这些请求保存在一个队列中。
* 使用负载均衡模式将这些请求发送给工作者。
* 接收工作者返回的回复。
* 将这些回复发送回原始请求的客户端。

代理的代码相当长，但值得理解。

这个程序最难的部分是（a）每个套接字读写的信封（envelope），以及（b）负载均衡算法。我们将依次讲解，从消息信封格式开始。

让我们逐步走一遍从客户端到工作者再返回的完整请求-回复链。在这段代码中，我们设置了客户端和工作者套接字的身份，以便更容易追踪消息帧。实际上，我们会让 ROUTER 套接字为连接生成身份。假设客户端的身份是 "CLIENT"，工作者的身份是 "WORKER"。客户端应用发送一个包含 "Hello" 的单帧消息。

由于 REQ 套接字会添加一个空分隔帧，ROUTER 套接字会添加连接身份，代理会从前端 ROUTER 套接字读取到客户端地址、空分隔帧和数据部分。

代理将此消息发送给工作者，前面加上所选工作者的地址，并额外加一个空部分以满足另一端的 REQ。

这个复杂的信封堆栈首先被后端 ROUTER 套接字处理，移除第一帧。然后工作者中的 REQ 套接字移除空部分，并将剩余部分提供给工作者应用。

工作者必须保存信封（即直到并包括空消息帧的所有部分），然后它可以对数据部分执行所需的操作。请注意，REP 套接字会自动执行此操作，但我们使用 REQ-ROUTER 模式，以便我们可以获得适当的负载均衡。

在返回路径上，消息与进入时相同，即后端套接字给代理一个五部分消息，代理向前端套接字发送一个三部分消息，客户端得到一个一部分消息。

现在让我们看看负载均衡算法。它要求客户端和工作者都使用 REQ 套接字，并且工作者正确存储和重放它们收到的消息上的信封。算法是：

* 创建一个轮询集，总是轮询后端，只有在有一个或多个工作者可用时才轮询前端。

* 以无限超时轮询活动。

* 如果后端有活动，我们要么有"准备就绪"消息，要么有客户端的回复。在任何一种情况下，我们将工作者地址（第一部分）存储在我们的工作者队列中，如果其余部分是客户端回复，我们通过前端将其发送回该客户端。

* 如果前端有活动，我们接受客户端请求，弹出下一个工作者（即最后使用的），并将请求发送到后端。这意味着发送工作者地址、空部分，然后是客户端请求的三个部分。

你现在应该看到，你可以基于工作者在其初始"准备就绪"消息中提供的信息，使用负载均衡算法的变体来重用和扩展。例如，工作者可能启动并进行性能自测，然后告诉代理他们有多快。然后代理可以选择最快的可用工作者，而不是最旧的。
