|
    .-----------+-----------.
    |           |           |
.---+----.  .---+----.  .---+----.
|  REQ   |  |  REQ   |  |  REQ   |
+--------+  +--------+  +--------+
| Worker |  | Worker |  | Worker |
#--------#  #--------#  #--------#
[[/code]]

这个代理（broker）执行以下操作：

* 接受来自一组客户端的连接。
* 接受来自一组工作者的连接。
* 接收来自客户端的请求，并将这些请求保存在一个队列中。
* 使用负载均衡模式将这些请求发送给工作者。
* 接收工作者返回的回复。
* 将这些回复发送回原始请求的客户端。

代理的代码相当长，但值得理解：

[[code type="example" title="负载均衡代理" name="lbbroker"]]
[[/code]]

这个程序最难的部分是（a）每个套接字读写的信封（envelope），以及（b）负载均衡算法。我们将依次讲解，从消息信封格式开始。

让我们逐步走一遍从客户端到工作者再返回的完整请求-回复链。在这段代码中，我们设置了客户端和工作者套接字的身份，以便更容易追踪消息帧。实际上，我们会让 ROUTER 套接字为连接生成身份。假设客户端的身份是 "CLIENT"，工作者的身份是 "WORKER"。客户端应用发送一个包含 "Hello" 的单帧消息[图]。

[[code type="textdiagram" title="客户端发送的消息"]]
          #---+-------#
帧1       | 5 | Hello |   数据帧
          #---+-------#
[[/code]]

由于 REQ 套接字会添加一个空分隔帧，ROUTER 套接字会添加连接身份，代理会从前端 ROUTER 套接字读取到客户端地址、空分隔帧和数据部分[图]。

[[code type="textdiagram" title="前端收到的消息"]]
          #---+--------#
帧1       | 6 | CLIENT |   客户端地址
          #---#--------#
帧2       | 0 |            空分隔帧
          #---#-------#
帧3       | 5 | Hello |    数据帧
          #---+-------#
[[/code]]

代理将此消息发送给工作者，前面加上所选工作者的地址，并额外加一个空部分以满足另一端的 REQ[图]。

[[code type="textdiagram" title="发送到后端的消息"]]
          #---+--------#
帧1       | 6 | WORKER |   工作者地址
          #---#--------#
帧2       | 0 |            空分隔帧
          #---#--------#
帧3       | 6 | CLIENT |   客户端身份
          #---#--------#
帧4       | 0 |            空分隔帧
          #---#-------#
帧5       | 5 | Hello |    数据帧
          #---+-------#
[[/code]]

这个复杂的信封堆栈首先被后端 ROUTER 套接字处理，移除第一帧。然后工作者中的 REQ 套接字移除空部分，并将剩余部分提供给工作者应用[图]。

[[code type="textdiagram" title="工作者收到的消息"]]
          #---+--------#
帧1       | 6 | CLIENT |   客户端身份
          #---#--------#
